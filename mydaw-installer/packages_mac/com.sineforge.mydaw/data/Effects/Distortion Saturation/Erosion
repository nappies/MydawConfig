
//---------------------------------------------------------------------
//
//    Erooosion v1.1 ~ time domain distortion using short delay ~
//
//    code by gomadare :)
//    CookDSP library by jmdumas
//    
//    This Plugin and Sourcecode is distributed under MIT License
//
//---------------------------------------------------------------------

desc:Erooosion (Gomadare)


slider1:gain_db=0<-150,12,1>gain (dB)

slider2:0.3<0,0.3,0.0001>★amount(ms)
slider3:0<0,10,0.01>extra amount(ms)
slider4:0<-0.1,0.1,0.0001>spread(ms)

slider15:0<0,7,1{Sine,Tri,Square,Saw Rising,Saw Falling,Mono Noise,Stereo Noise,Self}>★oscillator type
slider16:osc_freq=500<100,18000,1>★oscillator freq(hz)
slider17:osc_freq_spread=0<-100,100,1>oscillator freq spread(hz)

slider21:0<0,3,1{None,LP,HP,BP}>oscillator filter type
slider22:500<10,20000,1>cutoff freq(hz)
slider23:5<0.3,50,1>Q
Slider24:0<0,1,1{Off,On}>Use Test Signal (DEBUG)

slider30:1<0,2,1{None (Nearest Neighbor / Fastest),Linear (Better Quality / Faster),Cubic (Best Quality / Slow)}>Delay line interpolation

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

options:gfx_hz=90




@init

////MATH

function tanh(x)
(
    (exp(2*x) - 1) / (exp(2*x) + 1);
);



//////MEMALLOC


function memalloc(size)
(
    __memory_index = __memory_next + 8;
    __memory_next = __memory_index + size;
    memset(__memory_index, 0.0, size);
    __memory_index;
);

function memalloc(size, noreinit)
(
    noreinit == 0 ? (
        __memory_index = __memory_next + 8;
        __memory_next = __memory_index + size;
        memset(__memory_index, 0.0, size);
    ) : (
        __memory_index = __memory_next + 8;
        __memory_next = __memory_index + size;
    );
    __memory_index;
);






////////BUFFER




function buffer(size)
(
    this.buf = memalloc(size);
    this.size = size;
    this.hsize = this.size * 0.5;
    this.curval = 0.0;
    this.buf;
);

function buffer_init(h1)
(
    this.buf[0] = h1; 
);
function buffer_init(h1 h2)
(
    this.buf[0] = h1; this.buf[1] = h2; 
);
function buffer_init(h1 h2 h3)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; 
);
function buffer_init(h1 h2 h3 h4)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
);
function buffer_init(h1 h2 h3 h4 h5)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; 
);
function buffer_init(h1 h2 h3 h4 h5 h6)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; this.buf[22] = h23; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; this.buf[22] = h23; this.buf[23] = h24; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; this.buf[22] = h23; this.buf[23] = h24; 
    this.buf[24] = h25; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; this.buf[22] = h23; this.buf[23] = h24; 
    this.buf[24] = h25; this.buf[25] = h26; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; this.buf[22] = h23; this.buf[23] = h24; 
    this.buf[24] = h25; this.buf[25] = h26; this.buf[26] = h27; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; this.buf[22] = h23; this.buf[23] = h24; 
    this.buf[24] = h25; this.buf[25] = h26; this.buf[26] = h27; this.buf[27] = h28; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; this.buf[22] = h23; this.buf[23] = h24; 
    this.buf[24] = h25; this.buf[25] = h26; this.buf[26] = h27; this.buf[27] = h28; 
    this.buf[28] = h29; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; this.buf[22] = h23; this.buf[23] = h24; 
    this.buf[24] = h25; this.buf[25] = h26; this.buf[26] = h27; this.buf[27] = h28; 
    this.buf[28] = h29; this.buf[29] = h30; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; this.buf[22] = h23; this.buf[23] = h24; 
    this.buf[24] = h25; this.buf[25] = h26; this.buf[26] = h27; this.buf[27] = h28; 
    this.buf[28] = h29; this.buf[29] = h30; this.buf[30] = h31; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31 h32)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; this.buf[22] = h23; this.buf[23] = h24; 
    this.buf[24] = h25; this.buf[25] = h26; this.buf[26] = h27; this.buf[27] = h28; 
    this.buf[28] = h29; this.buf[29] = h30; this.buf[30] = h31; this.buf[31] = h32; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31 h32 h33)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; this.buf[22] = h23; this.buf[23] = h24; 
    this.buf[24] = h25; this.buf[25] = h26; this.buf[26] = h27; this.buf[27] = h28; 
    this.buf[28] = h29; this.buf[29] = h30; this.buf[30] = h31; this.buf[31] = h32; 
    this.buf[32] = h33; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31 h32 h33 h34)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; this.buf[22] = h23; this.buf[23] = h24; 
    this.buf[24] = h25; this.buf[25] = h26; this.buf[26] = h27; this.buf[27] = h28; 
    this.buf[28] = h29; this.buf[29] = h30; this.buf[30] = h31; this.buf[31] = h32; 
    this.buf[32] = h33; this.buf[33] = h34; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31 h32 h33 h34 h35)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; this.buf[22] = h23; this.buf[23] = h24; 
    this.buf[24] = h25; this.buf[25] = h26; this.buf[26] = h27; this.buf[27] = h28; 
    this.buf[28] = h29; this.buf[29] = h30; this.buf[30] = h31; this.buf[31] = h32; 
    this.buf[32] = h33; this.buf[33] = h34; this.buf[34] = h35; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31 h32 h33 h34 h35 h36)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; this.buf[22] = h23; this.buf[23] = h24; 
    this.buf[24] = h25; this.buf[25] = h26; this.buf[26] = h27; this.buf[27] = h28; 
    this.buf[28] = h29; this.buf[29] = h30; this.buf[30] = h31; this.buf[31] = h32; 
    this.buf[32] = h33; this.buf[33] = h34; this.buf[34] = h35; this.buf[35] = h36; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31 h32 h33 h34 h35 h36 h37)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; this.buf[22] = h23; this.buf[23] = h24; 
    this.buf[24] = h25; this.buf[25] = h26; this.buf[26] = h27; this.buf[27] = h28; 
    this.buf[28] = h29; this.buf[29] = h30; this.buf[30] = h31; this.buf[31] = h32; 
    this.buf[32] = h33; this.buf[33] = h34; this.buf[34] = h35; this.buf[35] = h36; 
    this.buf[36] = h37; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31 h32 h33 h34 h35 h36 h37 h38)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; this.buf[22] = h23; this.buf[23] = h24; 
    this.buf[24] = h25; this.buf[25] = h26; this.buf[26] = h27; this.buf[27] = h28; 
    this.buf[28] = h29; this.buf[29] = h30; this.buf[30] = h31; this.buf[31] = h32; 
    this.buf[32] = h33; this.buf[33] = h34; this.buf[34] = h35; this.buf[35] = h36; 
    this.buf[36] = h37; this.buf[37] = h38; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31 h32 h33 h34 h35 h36 h37 h38 h39)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; this.buf[22] = h23; this.buf[23] = h24; 
    this.buf[24] = h25; this.buf[25] = h26; this.buf[26] = h27; this.buf[27] = h28; 
    this.buf[28] = h29; this.buf[29] = h30; this.buf[30] = h31; this.buf[31] = h32; 
    this.buf[32] = h33; this.buf[33] = h34; this.buf[34] = h35; this.buf[35] = h36; 
    this.buf[36] = h37; this.buf[37] = h38; this.buf[38] = h39; 
);
function buffer_init(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31 h32 h33 h34 h35 h36 h37 h38 h39 h40)
(
    this.buf[0] = h1; this.buf[1] = h2; this.buf[2] = h3; this.buf[3] = h4; 
    this.buf[4] = h5; this.buf[5] = h6; this.buf[6] = h7; this.buf[7] = h8; 
    this.buf[8] = h9; this.buf[9] = h10; this.buf[10] = h11; this.buf[11] = h12; 
    this.buf[12] = h13; this.buf[13] = h14; this.buf[14] = h15; this.buf[15] = h16; 
    this.buf[16] = h17; this.buf[17] = h18; this.buf[18] = h19; this.buf[19] = h20; 
    this.buf[20] = h21; this.buf[21] = h22; this.buf[22] = h23; this.buf[23] = h24; 
    this.buf[24] = h25; this.buf[25] = h26; this.buf[26] = h27; this.buf[27] = h28; 
    this.buf[28] = h29; this.buf[29] = h30; this.buf[30] = h31; this.buf[31] = h32; 
    this.buf[32] = h33; this.buf[33] = h34; this.buf[34] = h35; this.buf[35] = h36; 
    this.buf[36] = h37; this.buf[37] = h38; this.buf[38] = h39; this.buf[39] = h40; 
);

function buffer_write(pos, signal)
(
    pos >= 0 && pos < this.size ? (
        this.buf[pos] = signal;
        this.buf[this.size] = this.buf[0];
        this.buf[this.size+1] = this.buf[1];
        this.buf[-1] = this.buf[this.size-1];
    );
);

function buffer_read(pos)
(
    pos >= 0 && pos < this.size ? (
        this.curval = this.buf[pos];
    );
    this.curval;
);

function buffer_fread(pos)
(
    this.curval = this.buf[pos];
    this.curval;
);

function buffer_nread(pos)
(
    this.buffer_read(pos * this.size);
);

function buffer_fnread(pos)
(
    this.buffer_fread(pos * this.size);
);

function buffer_read2(pos)
(
    pos >= 0 && pos < this.size ? (
        i_ = floor(pos);
        this.curval = this.buf[i_] + (this.buf[i_+1] - this.buf[i_]) * (pos - i_);
    );
    this.curval;
);

function buffer_fread2(pos)
(
    i_ = floor(pos);
    this.curval = this.buf[i_] + (this.buf[i_+1] - this.buf[i_]) * (pos - i_);
    this.curval;
);

function buffer_nread2(pos)
(
    this.buffer_read2(pos * this.size);
);

function buffer_fnread2(pos)
(
    this.buffer_fread2(pos * this.size);
);

function buffer_read3(pos)
(
    pos >= 0 && pos < this.size ? (
        i_ = floor(pos);
        f_ = pos - i_;
        x0_ = this.buf[i_-1]; x1_ = this.buf[i_]; 
        x2_ = this.buf[i_+1]; x3_ = this.buf[i_+2];
        a3_ = f_ * f_; a3_ -= 1.0; a3_ *= (1.0 / 6.0);
        a2_ = (f_ + 1.0) * 0.5; a0_ = a2_ - 1.0;
        a1_ = a3_ * 3.0; a2_ -= a1_; a0_ -= a3_; a1_ -= f_;
        a0_ *= f_; a1_ *= f_; a2_ *= f_; a3_ *= f_; a1_ += 1.0;
        this.curval = a0_*x0_ + a1_*x1_ + a2_*x2_ + a3_*x3_;
    );
    this.curval;
);

function buffer_fread3(pos)
(
    i_ = floor(pos);
    f_ = pos - i_;
    x0_ = this.buf[i_-1]; x1_ = this.buf[i_]; 
    x2_ = this.buf[i_+1]; x3_ = this.buf[i_+2];
    a3_ = f_ * f_; a3_ -= 1.0; a3_ *= (1.0 / 6.0);
    a2_ = (f_ + 1.0) * 0.5; a0_ = a2_ - 1.0;
    a1_ = a3_ * 3.0; a2_ -= a1_; a0_ -= a3_; a1_ -= f_;
    a0_ *= f_; a1_ *= f_; a2_ *= f_; a3_ *= f_; a1_ += 1.0;
    this.curval = a0_*x0_ + a1_*x1_ + a2_*x2_ + a3_*x3_;
    this.curval;
);

function buffer_nread3(pos)
(
    this.buffer_read3(pos * this.size);
);

function buffer_fnread3(pos)
(
    this.buffer_fread3(pos * this.size);
);

function buffer_lookup(pos)
(
    pos *= (this.hsize - 1);
    pos += this.hsize;
    this.buffer_fread(pos);
);

function buffer_lookup2(pos)
(
    pos *= (this.hsize - 1);
    pos += this.hsize;
    this.buffer_fread2(pos);
);

function buffer_lookup3(pos)
(
    pos *= (this.hsize - 2);
    pos += this.hsize;
    this.buffer_fread3(pos);
);

// private function for writing harmonic waveforms
function _buffer_gen10(buf size amps n)
(
    fac_ = 1 / (size * 0.5) * $pi;
    i_ = 0;
    loop(size,
        val_ = 0.0;
        j_ = 0;
        loop(n,
            amp_ = amps[j_];
            amp_ != 0 ? (
                val_ += sin((j_+1) * i_ * fac_) * amp_;
            );
            j_ += 1;
        );
        buf[i_] = val_;
        i_ += 1;
    );
    buf[size] = buf[0];
    buf[size+1] = buf[1];
    buf[-1] = buf[size-1];
);

function buffer_gen10(h1)
(
    __amps__ = memalloc(1);
    __amps__[0] = h1;
    _buffer_gen10(this.buf, this.size, __amps__, 1);
);
function buffer_gen10(h1 h2)
(
    __amps__ = memalloc(2);
    __amps__[0] = h1; __amps__[1] = h2;
    _buffer_gen10(this.buf, this.size, __amps__, 2);
);
function buffer_gen10(h1 h2 h3)
(
    __amps__ = memalloc(3);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3;
    _buffer_gen10(this.buf, this.size, __amps__, 3);
);
function buffer_gen10(h1 h2 h3 h4)
(
    __amps__ = memalloc(4);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    _buffer_gen10(this.buf, this.size, __amps__, 4);
);
function buffer_gen10(h1 h2 h3 h4 h5)
(
    __amps__ = memalloc(5);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5;
    _buffer_gen10(this.buf, this.size, __amps__, 5);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6)
(
    __amps__ = memalloc(6);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6;
    _buffer_gen10(this.buf, this.size, __amps__, 6);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7)
(
    __amps__ = memalloc(6);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7;
    _buffer_gen10(this.buf, this.size, __amps__, 7);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8)
(
    __amps__ = memalloc(8);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8;
    _buffer_gen10(this.buf, this.size, __amps__, 8);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9)
(
    __amps__ = memalloc(9);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8;
    __amps__[8] = h9;
    _buffer_gen10(this.buf, this.size, __amps__, 9);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10)
(
    __amps__ = memalloc(10);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8;
    __amps__[8] = h9; __amps__[9] = h10;
    _buffer_gen10(this.buf, this.size, __amps__, 10);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11)
(
    __amps__ = memalloc(11);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8;
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11;
    _buffer_gen10(this.buf, this.size, __amps__, 11);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12)
(
    __amps__ = memalloc(12);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8;
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12;
    _buffer_gen10(this.buf, this.size, __amps__, 12);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13)
(
    __amps__ = memalloc(13);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8;
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12;
    __amps__[12] = h13;
    _buffer_gen10(this.buf, this.size, __amps__, 13);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14)
(
    __amps__ = memalloc(14);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8;
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12;
    __amps__[12] = h13; __amps__[13] = h14;
    _buffer_gen10(this.buf, this.size, __amps__, 14);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15)
(
    __amps__ = memalloc(15);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8;
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12;
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15;
    _buffer_gen10(this.buf, this.size, __amps__, 15);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16)
(
    __amps__ = memalloc(16);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8;
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12;
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16;
    _buffer_gen10(this.buf, this.size, __amps__, 16);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17)
(
    __amps__ = memalloc(17);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8;
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12;
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16;
    __amps__[16] = h17;
    _buffer_gen10(this.buf, this.size, __amps__, 17);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18)
(
    __amps__ = memalloc(18);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8;
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12;
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16;
    __amps__[16] = h17; __amps__[17] = h18;
    _buffer_gen10(this.buf, this.size, __amps__, 18);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19)
(
    __amps__ = memalloc(19);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8;
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12;
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16;
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19;
    _buffer_gen10(this.buf, this.size, __amps__, 19);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20)
(
    __amps__ = memalloc(20);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8;
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12;
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16;
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20;
    _buffer_gen10(this.buf, this.size, __amps__, 20);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21)
(
    __amps__ = memalloc(21);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8;
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12;
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16;
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20;
    __amps__[20] = h21;
    _buffer_gen10(this.buf, this.size, __amps__, 21);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22)
(
    __amps__ = memalloc(22);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8;
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12;
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16;
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20;
    __amps__[20] = h21; __amps__[21] = h22;
    _buffer_gen10(this.buf, this.size, __amps__, 22);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23)
(
    __amps__ = memalloc(23);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8;
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12;
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16;
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20;
    __amps__[20] = h21; __amps__[21] = h22; __amps__[22] = h23;
    _buffer_gen10(this.buf, this.size, __amps__, 23);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24)
(
    __amps__ = memalloc(24);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4;
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8;
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12;
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16;
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20;
    __amps__[20] = h21; __amps__[21] = h22; __amps__[22] = h23; __amps__[23] = h24;
    _buffer_gen10(this.buf, this.size, __amps__, 24);
);

function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25)
(
    __amps__ = memalloc(25);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4; 
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8; 
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12; 
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16; 
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20; 
    __amps__[20] = h21; __amps__[21] = h22; __amps__[22] = h23; __amps__[23] = h24; 
    __amps__[24] = h25; 
    _buffer_gen10(this.buf, this.size, __amps__, 25);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26)
(
    __amps__ = memalloc(26);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4; 
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8; 
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12; 
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16; 
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20; 
    __amps__[20] = h21; __amps__[21] = h22; __amps__[22] = h23; __amps__[23] = h24; 
    __amps__[24] = h25; __amps__[25] = h26; 
    _buffer_gen10(this.buf, this.size, __amps__, 26);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27)
(
    __amps__ = memalloc(27);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4; 
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8; 
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12; 
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16; 
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20; 
    __amps__[20] = h21; __amps__[21] = h22; __amps__[22] = h23; __amps__[23] = h24; 
    __amps__[24] = h25; __amps__[25] = h26; __amps__[26] = h27; 
    _buffer_gen10(this.buf, this.size, __amps__, 27);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28)
(
    __amps__ = memalloc(28);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4; 
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8; 
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12; 
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16; 
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20; 
    __amps__[20] = h21; __amps__[21] = h22; __amps__[22] = h23; __amps__[23] = h24; 
    __amps__[24] = h25; __amps__[25] = h26; __amps__[26] = h27; __amps__[27] = h28; 
    _buffer_gen10(this.buf, this.size, __amps__, 28);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29)
(
    __amps__ = memalloc(29);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4; 
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8; 
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12; 
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16; 
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20; 
    __amps__[20] = h21; __amps__[21] = h22; __amps__[22] = h23; __amps__[23] = h24; 
    __amps__[24] = h25; __amps__[25] = h26; __amps__[26] = h27; __amps__[27] = h28; 
    __amps__[28] = h29; 
    _buffer_gen10(this.buf, this.size, __amps__, 29);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30)
(
    __amps__ = memalloc(30);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4; 
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8; 
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12; 
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16; 
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20; 
    __amps__[20] = h21; __amps__[21] = h22; __amps__[22] = h23; __amps__[23] = h24; 
    __amps__[24] = h25; __amps__[25] = h26; __amps__[26] = h27; __amps__[27] = h28; 
    __amps__[28] = h29; __amps__[29] = h30; 
    _buffer_gen10(this.buf, this.size, __amps__, 30);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31)
(
    __amps__ = memalloc(31);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4; 
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8; 
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12; 
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16; 
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20; 
    __amps__[20] = h21; __amps__[21] = h22; __amps__[22] = h23; __amps__[23] = h24; 
    __amps__[24] = h25; __amps__[25] = h26; __amps__[26] = h27; __amps__[27] = h28; 
    __amps__[28] = h29; __amps__[29] = h30; __amps__[30] = h31; 
    _buffer_gen10(this.buf, this.size, __amps__, 31);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31 h32)
(
    __amps__ = memalloc(32);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4; 
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8; 
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12; 
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16; 
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20; 
    __amps__[20] = h21; __amps__[21] = h22; __amps__[22] = h23; __amps__[23] = h24; 
    __amps__[24] = h25; __amps__[25] = h26; __amps__[26] = h27; __amps__[27] = h28; 
    __amps__[28] = h29; __amps__[29] = h30; __amps__[30] = h31; __amps__[31] = h32; 
    _buffer_gen10(this.buf, this.size, __amps__, 32);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31 h32 h33)
(
    __amps__ = memalloc(33);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4; 
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8; 
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12; 
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16; 
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20; 
    __amps__[20] = h21; __amps__[21] = h22; __amps__[22] = h23; __amps__[23] = h24; 
    __amps__[24] = h25; __amps__[25] = h26; __amps__[26] = h27; __amps__[27] = h28; 
    __amps__[28] = h29; __amps__[29] = h30; __amps__[30] = h31; __amps__[31] = h32; 
    __amps__[32] = h33; 
    _buffer_gen10(this.buf, this.size, __amps__, 33);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31 h32 h33 h34)
(
    __amps__ = memalloc(34);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4; 
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8; 
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12; 
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16; 
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20; 
    __amps__[20] = h21; __amps__[21] = h22; __amps__[22] = h23; __amps__[23] = h24; 
    __amps__[24] = h25; __amps__[25] = h26; __amps__[26] = h27; __amps__[27] = h28; 
    __amps__[28] = h29; __amps__[29] = h30; __amps__[30] = h31; __amps__[31] = h32; 
    __amps__[32] = h33; __amps__[33] = h34; 
    _buffer_gen10(this.buf, this.size, __amps__, 34);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31 h32 h33 h34 h35)
(
    __amps__ = memalloc(35);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4; 
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8; 
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12; 
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16; 
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20; 
    __amps__[20] = h21; __amps__[21] = h22; __amps__[22] = h23; __amps__[23] = h24; 
    __amps__[24] = h25; __amps__[25] = h26; __amps__[26] = h27; __amps__[27] = h28; 
    __amps__[28] = h29; __amps__[29] = h30; __amps__[30] = h31; __amps__[31] = h32; 
    __amps__[32] = h33; __amps__[33] = h34; __amps__[34] = h35; 
    _buffer_gen10(this.buf, this.size, __amps__, 35);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31 h32 h33 h34 h35 h36)
(
    __amps__ = memalloc(36);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4; 
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8; 
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12; 
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16; 
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20; 
    __amps__[20] = h21; __amps__[21] = h22; __amps__[22] = h23; __amps__[23] = h24; 
    __amps__[24] = h25; __amps__[25] = h26; __amps__[26] = h27; __amps__[27] = h28; 
    __amps__[28] = h29; __amps__[29] = h30; __amps__[30] = h31; __amps__[31] = h32; 
    __amps__[32] = h33; __amps__[33] = h34; __amps__[34] = h35; __amps__[35] = h36; 
    _buffer_gen10(this.buf, this.size, __amps__, 36);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31 h32 h33 h34 h35 h36 h37)
(
    __amps__ = memalloc(37);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4; 
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8; 
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12; 
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16; 
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20; 
    __amps__[20] = h21; __amps__[21] = h22; __amps__[22] = h23; __amps__[23] = h24; 
    __amps__[24] = h25; __amps__[25] = h26; __amps__[26] = h27; __amps__[27] = h28; 
    __amps__[28] = h29; __amps__[29] = h30; __amps__[30] = h31; __amps__[31] = h32; 
    __amps__[32] = h33; __amps__[33] = h34; __amps__[34] = h35; __amps__[35] = h36; 
    __amps__[36] = h37; 
    _buffer_gen10(this.buf, this.size, __amps__, 37);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31 h32 h33 h34 h35 h36 h37 h38)
(
    __amps__ = memalloc(38);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4; 
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8; 
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12; 
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16; 
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20; 
    __amps__[20] = h21; __amps__[21] = h22; __amps__[22] = h23; __amps__[23] = h24; 
    __amps__[24] = h25; __amps__[25] = h26; __amps__[26] = h27; __amps__[27] = h28; 
    __amps__[28] = h29; __amps__[29] = h30; __amps__[30] = h31; __amps__[31] = h32; 
    __amps__[32] = h33; __amps__[33] = h34; __amps__[34] = h35; __amps__[35] = h36; 
    __amps__[36] = h37; __amps__[37] = h38; 
    _buffer_gen10(this.buf, this.size, __amps__, 38);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31 h32 h33 h34 h35 h36 h37 h38 h39)
(
    __amps__ = memalloc(39);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4; 
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8; 
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12; 
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16; 
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20; 
    __amps__[20] = h21; __amps__[21] = h22; __amps__[22] = h23; __amps__[23] = h24; 
    __amps__[24] = h25; __amps__[25] = h26; __amps__[26] = h27; __amps__[27] = h28; 
    __amps__[28] = h29; __amps__[29] = h30; __amps__[30] = h31; __amps__[31] = h32; 
    __amps__[32] = h33; __amps__[33] = h34; __amps__[34] = h35; __amps__[35] = h36; 
    __amps__[36] = h37; __amps__[37] = h38; __amps__[38] = h39; 
    _buffer_gen10(this.buf, this.size, __amps__, 39);
);
function buffer_gen10(h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 h30 h31 h32 h33 h34 h35 h36 h37 h38 h39 h40)
(
    __amps__ = memalloc(40);
    __amps__[0] = h1; __amps__[1] = h2; __amps__[2] = h3; __amps__[3] = h4; 
    __amps__[4] = h5; __amps__[5] = h6; __amps__[6] = h7; __amps__[7] = h8; 
    __amps__[8] = h9; __amps__[9] = h10; __amps__[10] = h11; __amps__[11] = h12; 
    __amps__[12] = h13; __amps__[13] = h14; __amps__[14] = h15; __amps__[15] = h16; 
    __amps__[16] = h17; __amps__[17] = h18; __amps__[18] = h19; __amps__[19] = h20; 
    __amps__[20] = h21; __amps__[21] = h22; __amps__[22] = h23; __amps__[23] = h24; 
    __amps__[24] = h25; __amps__[25] = h26; __amps__[26] = h27; __amps__[27] = h28; 
    __amps__[28] = h29; __amps__[29] = h30; __amps__[30] = h31; __amps__[31] = h32; 
    __amps__[32] = h33; __amps__[33] = h34; __amps__[34] = h35; __amps__[35] = h36; 
    __amps__[36] = h37; __amps__[37] = h38; __amps__[38] = h39; __amps__[39] = h40; 
    _buffer_gen10(this.buf, this.size, __amps__, 40);
);

function buffer_saw(order)
(
    __amps__ = memalloc(order);
    i_ = 0;
    loop(order,
        __amps__[i_] = 1 / (i_ + 1);
        i_ += 1;
    );
    _buffer_gen10(this.buf, this.size, __amps__, order);
);

function buffer_square(order)
(
    __amps__ = memalloc(order);
    i_ = 0;
    loop(order,
        i_ & 1 ? __amps__[i_] = 0 : __amps__[i_] = 1 / (i_ + 1);
        i_ += 1;
    );
    _buffer_gen10(this.buf, this.size, __amps__, order);
);

function buffer_triangle(order)
(
    __amps__ = memalloc(order);
    i_ = 0;
    ph_ = 1;
    loop(order,
        i_ & 1 ? (
            __amps__[i_] = 0;
        ) : (
            __amps__[i_] = ph_ * 1 / pow(i_ + 1, 2);
            ph_ *= -1; 
        );
        i_ += 1;
    );
    _buffer_gen10(this.buf, this.size, __amps__, order);
);

function buffer_normalize(amp)
(
    mi_ = ma_ = 0;
    i_ = 0;
    loop(this.size,
        mi_ > this.buf[i_] ? mi_ = this.buf[i_];
        ma_ < this.buf[i_] ? ma_ = this.buf[i_];
        i_ += 1;
    );
    (mi_*mi_ > ma_*ma_) ? max_ = abs(mi_) : max_ = abs(ma_);
    max_ > 0 ? (
        ratio_ = amp / max_;
        i_ = 0;
        loop(this.size,
            this.buf[i_] *= ratio_;
            i_ += 1;
        );
    );
    this.buf[this.size] *= ratio_;
    this.buf[this.size+1] *= ratio_;
    this.buf[-1] *= ratio_;
);

function buffer_reset()
(
    i_ = 0;
    loop(this.size,
        this.buf[i_] = 0;
        i_ += 1;
    );
    this.buf[this.size] = 0;
    this.buf[this.size+1] = 0;
    this.buf[-1] = 0;
);

function buffer_reverse()
(
    hsize_ = floor(this.size / 2);
    size1_ = this.size - 1;
    i_ = 0;
    loop(hsize_,
        tmp_ = this.buf[i_];
        this.buf[i_] = this.buf[size1_ - i_];
        this.buf[size1_ - i_] = tmp_;
        i_ += 1;
    );
    this.buf[this.size] = this.buf[0];
    this.buf[this.size+1] = this.buf[1];
    this.buf[-1] = this.buf[this.size-1];
);

function buffer_window(which)
(
    // defaults to hanning
    which < 0 || which > 8 ? which = 1;
    which == 0 ? ( // hamming
        arg_ = 2.0 * $pi / (this.size-1);
        i_ = 0;
        loop(this.size,
            this.buf[i_] = 0.54 - 0.46 * cos(arg_ * i_);
            i_ += 1;
        );
    ) :
    which == 1 ? ( // hanning
        arg_ = 2.0 * $pi / (this.size-1);
        i_ = 0;
        loop(this.size,
            this.buf[i_] = 0.5 - 0.5 * cos(arg_ * i_);
            i_ += 1;
        );
    ) :
    which == 2 ? ( // bartlett
        arg_ = 2.0 / (this.size-1);
        hsize_ = floor((this.size-1)/2);
        i_ = 0;
        loop(hsize_,
            this.buf[i_] = i_ * arg_;
            i_ += 1;
        );
        loop(this.size - hsize_,
            this.buf[i_] = 2.0 - i_ * arg_;
            i_ += 1;
        );
    ) :
    which == 3 ? ( // blackman
        arg_ = 2.0 * $pi / (this.size-1);
        i_ = 0;
        loop(this.size,
            this.buf[i_] = 0.42323 - 0.49755 * cos(arg_*i_) + 0.07922 * cos(2*arg_*i_);
            i_ += 1;
        );
    ) :
    which == 4 ? ( // blackman_harris_4
        arg_ = 2.0 * $pi / (this.size-1);
        i_ = 0;
        loop(this.size,
            this.buf[i_] = 0.35875 - 0.48829 * cos(arg_*i_) + 0.14128 * cos(2*arg_*i_) - 0.01168 * cos(3*arg_*i_);
            i_ += 1;
        );
    ) :
    which == 5 ? ( // blackman_harris_7
        arg_ = 2.0 * $pi / (this.size-1);
        i_ = 0;
        loop(this.size,
            this.buf[i_] = 0.2712203606 - 0.4334446123 * cos(arg_*i_) + 0.21800412 * cos(2*arg_*i_) - 0.0657853433 * cos(3*arg_*i_) + 0.0107618673 * cos(4*arg_*i_) - 0.0007700127 * cos(5*arg_*i_) + 0.00001368088 * cos(6*arg_*i_);
            i_ += 1;
        );
    ) :
    which == 6 ? ( // tuckey 50%
        i_ = 0;
        step_ = floor(0.5 * this.size / 2);
        loop(step_,
            this.buf[i_] = 0.5 * (1 + cos($pi * (2 * i_ / (0.5 * this.size) - 1)));
            i_ += 1;
        );
        step_ = this.size * (1 - 0.5 / 2) - step_;
        loop(step_,
            this.buf[i_] = 1.0;
            i_ += 1;
        );
        step_ = this.size - step_;
        loop(step_,
            this.buf[i_] = 0.5 * (1 + cos($pi * (2 * i_ / (0.5 * this.size) - 2 / 0.5 + 1)));
            i_ += 1;
        );
    ) :
    which == 7 ? ( // halfsine
        arg_ = $pi / (this.size-1);
        i_ = 0;
        loop(this.size,
            this.buf[i_] = sin(arg_ * i_);
            i_ += 1;
        );
    ) :
    which == 8 ? ( // parabolic
        size1_ = this.size - 1;
        rdur_ = 1 / size1_;
        rdur2_ = rdur_ * rdur_;
        level_ = 0;
        slope_ = 4 * (rdur_ - rdur2_);
        curve_ = -8 * rdur2_;

        i_ = 0;
        loop(size1_,
            this.buf[i_] = level_;
            level_ += slope_;
            slope_ += curve_;
            i_ += 1;
        );
        this.buf[size1_] = this.buf[0];
    );
    this.buf[this.size] = this.buf[0];
    this.buf[this.size+1] = this.buf[1];
    this.buf[-1] = this.buf[this.size-1];
);

function buffer_atan(slope)
(
    invh_ = 1.0 / this.hsize;
    invpi_ = 1.0 / $pi; 
    drv_ = 1.0 - slope;
    drv_ = drv_ * drv_ * drv_ * $pi;
    i_ = 0;
    loop(this.hsize + 1,
        t_ = i_ * invh_ - 1;
        val_ = atan2(t_, drv_) * invpi_;
        i_ == 0 ? fac_ = 1.0 / -val_;
        val_ *= fac_;
        this.buf[i_] = val_;
        this.buf[this.size - i_] = -val_;
        i_ += 1;
    );
);

function buffer_clip(mini maxi)
(
    k_ = -1;
    loop(this.size+3,
        this.buf[k_] = max(min(this.buf[k_], maxi), mini);
        k_ += 1;
    );
);

function buffer_mul(x)
(
    k_ = -1;
    loop(this.size+3,
        this.buf[k_] = this.buf[k_] * x;
        k_ += 1;
    );
);

function buffer_div(x)
(
    k_ = -1;
    loop(this.size+3,
        this.buf[k_] = this.buf[k_] / x;
        k_ += 1;
    );
);

function buffer_rdiv(x)
(
    k_ = -1;
    loop(this.size+3,
        this.buf[k_] = x / this.buf[k_];
        k_ += 1;
    );
);

function buffer_add(x)
(
    k_ = -1;
    loop(this.size+3,
        this.buf[k_] = this.buf[k_] + x;
        k_ += 1;
    );
);

function buffer_sub(x)
(
    k_ = -1;
    loop(this.size+3,
        this.buf[k_] = this.buf[k_] - x;
        k_ += 1;
    );
);

function buffer_rsub(x)
(
    k_ = -1;
    loop(this.size+3,
        this.buf[k_] = x - this.buf[k_];
        k_ += 1;
    );
);












///////////////DELAY


function delay(size)
(
    this.buf = memalloc(size);
    this.size = size;
    this.curpos = 0;
    this.curval = 0;
);

function delay_write(signal)
(
    this.buf[this.curpos] = signal;
    this.buf[this.size] = this.buf[0];
    this.buf[this.size+1] = this.buf[1];
    this.buf[-1] = this.buf[this.size-1];
    this.curpos += 1;
    this.curpos == this.size ? this.curpos = 0;
);

function delay_read(delay)
(
    delay >= 0 && delay < this.size ? (
        pos_ = this.curpos - delay;
        pos_ < 0 ? pos_ += this.size;
        this.curval = this.buf[floor(pos_)];
    );
    this.curval;
);

function delay_fread(delay)
(
    pos_ = this.curpos - delay;
    pos_ < 0 ? pos_ += this.size;
    this.curval = this.buf[floor(pos_)];
    this.curval;
);

function delay_sread(delay)
(
    this.delay_read(delay * srate);
);

function delay_fsread(delay)
(
    this.delay_fread(delay * srate);
);

function delay_read2(delay)
(
    delay >= 0 && delay < this.size ? (
        pos_ = this.curpos - delay;
        pos_ < 0 ? pos_ += this.size;
        ip_ = floor(pos_);
        this.curval = this.buf[ip_] + (this.buf[ip_+1] - this.buf[ip_]) * (pos_ - ip_);
    );
    this.curval;
);

function delay_fread2(delay)
(
    pos_ = this.curpos - delay;
    pos_ < 0 ? pos_ += this.size;
    ip_ = floor(pos_);
    this.curval = this.buf[ip_] + (this.buf[ip_+1] - this.buf[ip_]) * (pos_ - ip_);
    this.curval;
);

function delay_sread2(delay)
(
    this.delay_read2(delay * srate);
);

function delay_fsread2(delay)
(
    this.delay_fread2(delay * srate);
);

function delay_read3(delay)
(
    delay >= 0 && delay < this.size ? (
        pos_ = this.curpos - delay;
        pos_ < 0 ? pos_ += this.size;
        i_ = floor(pos_);
        f_ = pos_ - i_;
        x0_ = this.buf[i_-1]; x1_ = this.buf[i_]; 
        x2_ = this.buf[i_+1]; x3_ = this.buf[i_+2];
        a3_ = f_ * f_; a3_ -= 1.0; a3_ *= (1.0 / 6.0);
        a2_ = (f_ + 1.0) * 0.5; a0_ = a2_ - 1.0;
        a1_ = a3_ * 3.0; a2_ -= a1_; a0_ -= a3_; a1_ -= f_;
        a0_ *= f_; a1_ *= f_; a2_ *= f_; a3_ *= f_; a1_ += 1.0;
        this.curval = a0_*x0_ + a1_*x1_ + a2_*x2_ + a3_*x3_;
    );
    this.curval;
);

function delay_fread3(delay)
(
    pos_ = this.curpos - delay;
    pos_ < 0 ? pos_ += this.size;
    i_ = floor(pos_);
    f_ = pos_ - i_;
    x0_ = this.buf[i_-1]; x1_ = this.buf[i_]; 
    x2_ = this.buf[i_+1]; x3_ = this.buf[i_+2];
    a3_ = f_ * f_; a3_ -= 1.0; a3_ *= (1.0 / 6.0);
    a2_ = (f_ + 1.0) * 0.5; a0_ = a2_ - 1.0;
    a1_ = a3_ * 3.0; a2_ -= a1_; a0_ -= a3_; a1_ -= f_;
    a0_ *= f_; a1_ *= f_; a2_ *= f_; a3_ *= f_; a1_ += 1.0;
    this.curval = a0_*x0_ + a1_*x1_ + a2_*x2_ + a3_*x3_;
    this.curval;
);

function delay_sread3(delay)
(
    this.delay_read3(delay * srate);
);

function delay_fsread3(delay)
(
    this.delay_fread3(delay * srate);
);


function _sdelay_compute_time(delay)
(
    this.timer == 0 ? (
        this.current = (this.current + 1) % 2;
        this.sampdel = floor(delay + 0.5);
        this.xfade = floor(this.xfade + 0.5);
        this.xfade > this.sampdel ? this.xfade = this.sampdel;
        this.xfade <= 0 ? this.xfade = 1;
        this.current == 0 ? (
            this.sampdel1 = delay;
            this.inc1 = 1.0 / this.xfade;
            this.inc2 = -this.inc1;
        ) : (
            this.sampdel2 = delay;
            this.inc2 = 1.0 / this.xfade;
            this.inc1 = -this.inc2;
        );
    );
    this.timer += 1;
    this.timer == this.sampdel ? this.timer = 0;
);

function _sdelay_update_amps()
(
    this.amp1 += this.inc1;
    this.amp1 < 0 ? this.amp1 = 0.0 : this.amp1 > 1 ? this.amp1 = 1.0;
    this.amp2 += this.inc2;
    this.amp2 < 0 ? this.amp2 = 0.0 : this.amp2 > 1 ? this.amp2 = 1.0;
);

function sdelay(size xfade)
(
    this.delay.delay(size);
    this.xfade = xfade;
    this.current = 1;
    this.timer = 0;
    this.amp1 = 0.0;
    this.amp2 = 1.0;
    this.inc1 = this.inc2 = 0.0;
);

function sdelay_write(signal)
(
    this.delay.delay_write(signal);
);

function sdelay_set_xfade(xfade)
(
    this.xfade = xfade;
);

function sdelay_read(delay)
(
    this._sdelay_compute_time(delay);
    val_ = this.delay.delay_read(this.sampdel1) * this.amp1;
    val_ += this.delay.delay_read(this.sampdel2) * this.amp2;
    this._sdelay_update_amps();
    val_;
);

function sdelay_fread(delay)
(
    this._sdelay_compute_time(delay);
    val_ = this.delay.delay_fread(this.sampdel1) * this.amp1;
    val_ += this.delay.delay_fread(this.sampdel2) * this.amp2;
    this._sdelay_update_amps();
    val_;
);

function sdelay_sread(delay)
(
    this.sdelay_read(delay * srate);
);

function sdelay_fsread(delay)
(
    this.sdelay_fread(delay * srate);
);

function sdelay_read2(delay)
(
    this._sdelay_compute_time(delay);
    val_ = this.delay.delay_read2(this.sampdel1) * this.amp1;
    val_ += this.delay.delay_read2(this.sampdel2) * this.amp2;
    this._sdelay_update_amps();
    val_;
);

function sdelay_fread2(delay)
(
    this._sdelay_compute_time(delay);
    val_ = this.delay.delay_fread2(this.sampdel1) * this.amp1;
    val_ += this.delay.delay_fread2(this.sampdel2) * this.amp2;
    this._sdelay_update_amps();
    val_;
);

function sdelay_sread2(delay)
(
    this.sdelay_read2(delay * srate);
);

function sdelay_fsread2(delay)
(
    this.sdelay_fread2(delay * srate);
);

function sdelay_read3(delay)
(
    this._sdelay_compute_time(delay);
    val_ = this.delay.delay_read3(this.sampdel1) * this.amp1;
    val_ += this.delay.delay_read3(this.sampdel2) * this.amp2;
    this._sdelay_update_amps();
    val_;
);

function sdelay_fread3(delay)
(
    this._sdelay_compute_time(delay);
    val_ = this.delay.delay_fread3(this.sampdel1) * this.amp1;
    val_ += this.delay.delay_fread3(this.sampdel2) * this.amp2;
    this._sdelay_update_amps();
    val_;
);

function sdelay_sread3(delay)
(
    this.sdelay_read3(delay * srate);
);

function sdelay_fsread3(delay)
(
    this.sdelay_fread3(delay * srate);
);








/////// FILTERS



function lop(freq)
(
  this.y0 = 0;
  this.ny = srate * 0.49;
  freq < 0.1 ? freq = 0.1 : freq > this.ny ? freq = this.ny;
  this.freq = freq; 
  this.c = exp(-2 * $pi * this.freq / srate);
);

function lop_set_freq(freq)
(
  freq < 0.1 ? freq = 0.1 : freq > this.ny ? freq = this.ny;
  this.freq = freq; 
  this.c = exp(-2 * $pi * this.freq / srate);
);

function lop_do(signal)
(
  this.y0 = signal + (this.y0 - signal) * this.c;
  this.y0;
);

/******************************************************* 
HIP
===

First-order IIR highpass filter.

Description
-----------

The hip object initializes a first-order IIR highpass filter. 
It takes the cutoff frequency, in Hz, as argument.

It must be used with a variable name as prefix (object oriented).

Initializer
-----------

#### hip(freq) ####

Initializes a highpass filter with `freq` as the cutoff frequency.

Methods
-------

#### hip_set_freq(freq) ####

Sets a new cutoff frequency `freq`, in Hz.

#### hip_do(signal) ####

Processes one samples of an input signal `signal` and outputs
the filtered sample.

Example
-------

    desc:Interpolated Stereo Highpass Filter

    import cookdsp.jsfx-inc

    slider1:3500<50,10000>Cutoff Frequency In Hz
    slider2:1<0.01,10>Interpolation Time In Seconds

    @init
    // Initializes the interpolator
    interp.lop(1.0 / slider2);
    // Initializes the filters
    filt1.hip(slider1);
    filt2.hip(slider1);

    @slider
    // Sets the interpolator's frequency
    interp.lop_set_freq(1.0 / slider2);

    @sample
    // Compute and sets the filters's frequency
    freq = interp.lop_do(slider1);
    filt1.hip_set_freq(freq);
    filt2.hip_set_freq(freq);
    // Filters the input signal
    spl0 = filt1.hip_do(spl0);
    spl1 = filt2.hip_do(spl1);

********************************************************/
function _hip_compute_coeffs()
(
  this.b1 = exp(-2 * $pi * this.freq / srate);
  this.a0 = (1 + this.b1) / 2;
  this.a1 = -this.a0;
);

function hip(freq)
(
  this.x0 = this.y0 = 0;
  this.ny = srate * 0.49;
  freq < 0.1 ? freq = 0.1 : freq > this.ny ? freq = this.ny;
  this.freq = freq; 
  this._hip_compute_coeffs();
);

function hip_set_freq(freq)
(
  freq < 0.1 ? freq = 0.1 : freq > this.ny ? freq = this.ny;
  this.freq = freq; 
  this._hip_compute_coeffs();
);

function hip_do(signal)
(
  this.y0 = signal * this.a0 + this.x0 * this.a1 + this.y0 * this.b1;
  this.x0 = signal;
  this.y0;
);

/******************************************************* 
BP
===

Second-order IIR bandpass filter.


Description
-----------

The bp object initializes a second-order IIR bandpass
filter. It takes center frequency, in Hz, and Q as 
arguments.

It must be used with a variable name as prefix (object oriented).

Initializer
-----------

#### bp(freq, q) ####

Initializes a second order IIR bandpass filter with `freq` as the
center frequency, in Hz, and `q` as the Q factor (ie. the amount 
of resonance). The bandwidth of the filter is computed as `freq / q`.

Methods
-------

#### bp_set_freq(freq) ####

Sets a new center frequency, `freq`, to the filter.

#### bp_set_q(q) ####

Sets a new Q, ie. amount of resonance, to the filter.

#### bp_do(signal) ####

Processes one samples of an input signal `signal` and outputs
the filtered sample.

Example
-------

    desc:Second Order Stereo Bandpass Filter

    import cookdsp.jsfx-inc

    slider1:3500<100,10000>Center Frequency In Hz
    slider2:20<1,100>Q Factor

    @init
    // Initializes the filters
    filt1.bp(slider1, slider2);
    filt2.bp(slider1, slider2);

    @slider
    filt1.bp_set_freq(slider1);
    filt2.bp_set_freq(slider1);
    filt1.bp_set_q(slider2);
    filt2.bp_set_q(slider2);

    @sample
    // Filters the input signal
    spl0 = filt1.bp_do(spl0);
    spl1 = filt2.bp_do(spl1);

********************************************************/
// Private function //
function _bp_compute_coeffs()
(
    bw_ = this.freq / this.q;
    this.b2 = exp(-2 * $pi / srate * bw_);
    this.b1 = (-4.0 * this.b2) / (1.0 + this.b2) * cos(2 * $pi * this.freq / srate);
    this.a1 = 1.0 - sqrt(this.b2);
);

function bp(freq q)
(
    this.ny = srate * 0.49;
    freq < 20 ? freq = 20 : freq > this.ny ? freq = this.ny; 
    this.freq = freq;
    q < 0.5 ? q = 0.5 : q > 1000 ? q = 1000;
    this.q = q;
    this.x1 = this.x2 = this.y1 = this.y2 = 0.0;
    this._bp_compute_coeffs();
);

function bp_set_freq(freq)
(
    freq < 20 ? freq = 20 : freq > this.ny ? freq = this.ny; 
    this.freq = freq;
    this._bp_compute_coeffs();
);

function bp_set_q(q)
(
    q < 0.5 ? q = 0.5 : q > 1000 ? q = 1000;
    this.q = q;
    this._bp_compute_coeffs(); 
);

function bp_do(signal)
(
    tmp_ = (this.a1 * signal) - (this.a1 * this.x2) - (this.b1 * this.y1) - (this.b2 * this.y2);
    this.x2 = this.x1; this.x1 = signal; this.y2 = this.y1; this.y1 = tmp_;
    tmp_;
);

/******************************************************* 
BUTLP
=====

Second-order Butterworth lowpass filter.

Description
-----------

The butlp object initializes a second-order IIR Butterworth 
lowpass filter. It takes the cutoff frequency, in Hz, as argument.

The Butterworth filter is a type of signal processing filter designed 
to have as flat a frequency response as possible in the passband.

It must be used with a variable name as prefix (object oriented).

Initializer
-----------

#### butlp(freq) ####

Initializes a lowpass filter with `freq` as the cutoff frequency.

Methods
-------

#### butlp_set_freq(freq) ####

Sets a new cutoff frequency `freq`, in Hz.

#### butlp_do(signal) ####

Processes one samples of an input signal `signal` and outputs
the filtered sample.

Example
-------

    desc:Butterworth Lowpass Filter

    import cookdsp.jsfx-inc

    slider1:3500<100,10000>Cutoff Frequency In Hz

    @init
    // Initializes the filters
    filt1.butlp(slider1);
    filt2.butlp(slider1);

    @slider
    filt1.butlp_set_freq(slider1);
    filt2.butlp_set_freq(slider1);

    @sample
    // Filters the input signal
    spl0 = filt1.butlp_do(spl0);
    spl1 = filt2.butlp_do(spl1);

********************************************************/
function _butlp_compute_coeffs(freq)
(
    freq < 1.0 ? freq = 1.0 : freq > this.ny ? freq = this.ny;
    this.freq = freq; 
    c_ = 1.0 / tan(this.pioversr * this.freq);
    c2_ = c_ * c_;
    this.a0 = this.a2 = 1.0 / (1.0 + this.sqrt2 * c_ + c2_);
    this.a1 = 2.0 * this.a0;
    this.b1 = this.a1 * (1.0 - c2_);
    this.b2 = this.a0 * (1.0 - this.sqrt2 * c_ + c2_);
);

function butlp(freq)
(
    this.x1 = this.x2 = this.y1 = this.y2 = 0.0;
    this.pioversr = $pi / srate;
    this.sqrt2 = sqrt(2.0);
    this.ny = srate * 0.49;
    this._butlp_compute_coeffs(freq);
);

function butlp_set_freq(freq)
(
    this._butlp_compute_coeffs(freq);
);

function butlp_do(signal)
(
    tmp_ = this.a0 * signal + this.a1 * this.x1 + this.a2 * this.x2 - this.b1 * this.y1 - this.b2 * this.y2;
    this.x2 = this.x1; this.x1 = signal; this.y2 = this.y1; this.y1 = tmp_;
    tmp_;
);

/******************************************************* 
BUTHP
=====

Second-order Butterworth highpass filter.

Description
-----------

The buthp object initializes a second-order IIR Butterworth 
highpass filter. It takes the cutoff frequency, in Hz, as argument.

The Butterworth filter is a type of signal processing filter designed 
to have as flat a frequency response as possible in the passband.

It must be used with a variable name as prefix (object oriented).

Initializer
-----------

#### buthp(freq) ####

Initializes a highpass filter with `freq` as the cutoff frequency.

Methods
-------

#### buthp_set_freq(freq) ####

Sets a new cutoff frequency `freq`, in Hz.

#### buthp_do(signal) ####

Processes one samples of an input signal `signal` and outputs
the filtered sample.

Example
-------

    desc:Butterworth Highpass Filter

    import cookdsp.jsfx-inc

    slider1:3500<100,10000>Cutoff Frequency In Hz

    @init
    // Initializes the filter
    filt1.buthp(slider1);
    filt2.buthp(slider1);

    @slider
    filt1.buthp_set_freq(slider1);
    filt2.buthp_set_freq(slider1);

    @sample
    // Filters the input signal
    spl0 = filt1.buthp_do(spl0);
    spl1 = filt2.buthp_do(spl1);

********************************************************/
function _buthp_compute_coeffs(freq)
(
    freq < 1.0 ? freq = 1.0 : freq > this.ny ? freq = this.ny;
    this.freq = freq; 
    c_ = tan(this.pioversr * this.freq);
    c2_ = c_ * c_;
    this.a0 = this.a2 = 1.0 / (1.0 + this.sqrt2 * c_ + c2_);
    this.a1 = -2.0 * this.a0;
    this.b1 = 2.0 * this.a0 * (c2_ - 1.0);
    this.b2 = this.a0 * (1.0 - this.sqrt2 * c_ + c2_);
);

function buthp(freq)
(
    this.x1 = this.x2 = this.y1 = this.y2 = 0.0;
    this.pioversr = $pi / srate;
    this.sqrt2 = sqrt(2.0);
    this.ny = srate * 0.49;
    this._buthp_compute_coeffs(freq);
);

function buthp_set_freq(freq)
(
    this._buthp_compute_coeffs(freq);
);

function buthp_do(signal)
(
    tmp_ = this.a0 * signal + this.a1 * this.x1 + this.a2 * this.x2 - this.b1 * this.y1 - this.b2 * this.y2;
    this.x2 = this.x1; this.x1 = signal; this.y2 = this.y1; this.y1 = tmp_;
    tmp_;
);

/******************************************************* 
BUTBP
=====

Second-order Butterworth bandpass filter.

Description
-----------

The butbp object initializes a second-order IIR Butterworth 
bandpass filter. It takes the center frequency, in Hz, and 
the Q, as argument.

The Butterworth filter is a type of signal processing filter designed 
to have as flat a frequency response as possible in the passband.

It must be used with a variable name as prefix (object oriented).

Initializer
-----------

#### butbp(freq, q) ####

Initializes a bandpass filter with `freq` as the center frequency,
and `q` as the inverse of the filter's bandwidth.

Methods
-------

#### butbp_set_freq(freq) ####

Sets a new center frequency `freq`, in Hz.

#### butbp_set_q(q) ####

Sets a new `q`. The Q of the filter is the inverse of the bandwidth.

#### butbp_do(signal) ####

Processes one samples of an input signal `signal` and outputs
the filtered sample.

Example
-------

    desc:Butterworth Bandpass Filter

    import cookdsp.jsfx-inc

    slider1:3500<100,10000>Cutoff Frequency In Hz
    slider2:5<1,100>Filter Q

    @init
    // Initializes the filter
    filt1.butbp(slider1, slider2);
    filt2.butbp(slider1, slider2);

    @slider
    filt1.butbp_set_freq(slider1);
    filt2.butbp_set_freq(slider1);
    filt1.butbp_set_q(slider2);
    filt2.butbp_set_q(slider2);

    @sample
    // Filters the input signal
    spl0 = filt1.butbp_do(spl0);
    spl1 = filt2.butbp_do(spl1);

********************************************************/
function _butbp_compute_coeffs()
(
    bw_ = this.freq / this.q;
    c_ = 1.0 / tan(this.pioversr * bw_);
    d_ = 2.0 * cos(2.0 * this.pioversr * this.freq);
    this.a0 = 1.0 / (1.0 + c_);
    this.a2 = -this.a0;
    this.b1 = this.a2 * c_ * d_;
    this.b2 = this.a0 * (c_ - 1.0);
);

function butbp(freq q)
(
    freq < 1.0 ? freq = 1.0 : freq > this.ny ? freq = this.ny;
    this.freq = freq; 
    q < 0.5 ? q = 0.5 : q > 1000 ? q = 1000;
    this.q = q; 
    this.x1 = this.x2 = this.y1 = this.y2 = 0.0;
    this.pioversr = $pi / srate;
    this.ny = srate * 0.49;
    this._butbp_compute_coeffs();
);

function butbp_set_freq(freq)
(
    freq < 1.0 ? freq = 1.0 : freq > this.ny ? freq = this.ny;
    this.freq = freq; 
    this._butbp_compute_coeffs();
);

function butbp_set_q(q)
(
    q < 0.5 ? q = 0.5 : q > 1000 ? q = 1000;
    this.q = q; 
    this._butbp_compute_coeffs();
);

function butbp_do(signal)
(
    tmp_ = this.a0 * signal + this.a2 * this.x2 - this.b1 * this.y1 - this.b2 * this.y2;
    this.x2 = this.x1; this.x1 = signal; this.y2 = this.y1; this.y1 = tmp_;
    tmp_;
);

/******************************************************* 
BUTBR
=====

Second-order Butterworth band reject filter.

Description
-----------

The butbp object initializes a second-order IIR Butterworth 
band reject filter. It takes the center frequency, in Hz, and 
the Q, as argument.

The Butterworth filter is a type of signal processing filter designed 
to have as flat a frequency response as possible in the passband.

It must be used with a variable name as prefix (object oriented).

Initializer
-----------

#### butbr(freq, q) ####

Initializes a band reject filter with `freq` as the center frequency,
and `q` as the inverse of the filter's bandwidth.

Methods
-------

#### butbr_set_freq(freq) ####

Sets a new center frequency `freq`, in Hz.

#### butbr_set_q(q) ####

Sets a new `q`. The Q of the filter is the inverse of the bandwidth.

#### butbr_do(signal) ####

Processes one samples of an input signal `signal` and outputs
the filtered sample.

Example
-------

    desc:Butterworth Band Reject Filter

    import cookdsp.jsfx-inc

    slider1:3500<100,10000>Cutoff Frequency In Hz
    slider2:5<1,100>Filter Q

    @init
    // Initializes the filter
    filt1.butbr(slider1, slider2);
    filt2.butbr(slider1, slider2);

    @slider
    filt1.butbr_set_freq(slider1);
    filt2.butbr_set_freq(slider1);
    filt1.butbr_set_q(slider2);
    filt2.butbr_set_q(slider2);

    @sample
    // Filters the input signal
    spl0 = filt1.butbr_do(spl0);
    spl1 = filt2.butbr_do(spl1);

********************************************************/
function _butbr_compute_coeffs()
(
    bw_ = this.freq / this.q;
    c_ = tan(this.pioversr * bw_);
    d_ = 2.0 * cos(2.0 * this.pioversr * this.freq);
    this.a0 = this.a2 = 1.0 / (1.0 + c_);
    this.a1 = this.b1 = -this.a0 * d_;
    this.b2 = this.a0 * (1.0 - c_);
);

function butbr(freq q)
(
    freq < 1.0 ? freq = 1.0 : freq > this.ny ? freq = this.ny;
    this.freq = freq; 
    q < 0.5 ? q = 0.5 : q > 1000 ? q = 1000;
    this.q = q; 
    this.x1 = this.x2 = this.y1 = this.y2 = 0.0;
    this.pioversr = $pi / srate;
    this.ny = srate * 0.49;
    this._butbr_compute_coeffs();
);

function butbr_set_freq(freq)
(
    freq < 1.0 ? freq = 1.0 : freq > this.ny ? freq = this.ny;
    this.freq = freq; 
    this._butbr_compute_coeffs();
);

function butbr_set_q(q)
(
    q < 0.5 ? q = 0.5 : q > 1000 ? q = 1000;
    this.q = q; 
    this._butbr_compute_coeffs();
);

function butbr_do(signal)
(
    tmp_ = this.a0 * signal + this.a1 * this.x1 + this.a2 * this.x2 - this.b1 * this.y1 - this.b2 * this.y2;
    this.x2 = this.x1; this.x1 = signal; this.y2 = this.y1; this.y1 = tmp_;
    tmp_;
);

/******************************************************* 
APASS
=====

Second-order phase shifter allpass.


Description
-----------

This kind of filter is used in phaser implementation. The signal
produced by this filter, when added to original sound, creates a 
notch in the spectrum at a frequency given by the `freq` argument.
The `apass` object also takes the bandwidth of the filter and the
feedback coefficient as argument.

It must be used with a variable name as prefix (object oriented).

Initializer
-----------

#### apass(freq, bw [, feed]) ####

Initializes a second order IIR phase shifter allpass with `freq` as 
the center frequency, in Hz, and `bw` as the bandwidth of the , also 
in Hz. The optional argument `feed` is the feedback coefficient. It
defaults to 0.

Methods
-------

#### apass_set_freq(freq) ####

Sets a new center frequency, `freq`, to the filter.

#### apass_set_bw(bw) ####

Sets a new bandwidth, `bw`, to the filter.

#### apass_set_feed(feed) ####

Sets a new feedback coefficient, `feed`, to the filter.

#### apass_do(signal) ####

Processes one samples of an input signal `signal` and outputs
the filtered sample.

Example
-------

    desc: Second-Order Phase Shifter Allpass

    import cookdsp.jsfx-inc

    slider1:1000<100,10000>Notch Frequency (Hz)
    slider2:1000<100,2000>Bandwidth (Hz)
    slider3:0<0,0.99>Feedback

    @init
    apL.apass(slider1, slider2, slider3);
    apR.apass(slider1, slider2, slider3);

    @slider
    apL.apass_set_freq(slider1);
    apR.apass_set_freq(slider1);
    apL.apass_set_bw(slider2);
    apR.apass_set_bw(slider2);
    apL.apass_set_feed(slider3);
    apR.apass_set_feed(slider3);

    @sample
    filt = apL.apass_do(spl0);
    spl0 = (spl0 + filt) * 0.5;  

    filt = apR.apass_do(spl1);
    spl1 = (spl1 + filt) * 0.5;

********************************************************/
// Private function //
function _apass_compute_coeffs()
(
    r_ = exp(-$pi * this.bw / srate);
    this.a = r_ * r_;
    this.b = -2 * r_ * cos(2 * $pi * this.freq / srate);
);

function apass(freq bw feed)
(
    this.ny = srate * 0.49;
    freq < 10 ? freq = 10 : freq > this.ny ? freq = this.ny; 
    this.freq = freq;
    bw < 1 ? bw = 1 : bw > this.ny ? bw = this.ny;
    this.bw = bw;
    feed < 0 ? feed = 0 : feed > 0.999 ? feed = 0.999;
    this.feed = feed;
    this.y = this.y1 = this.y2 = 0.0;
    this._apass_compute_coeffs();
);

function apass(freq bw)
(
    this.apass(freq, bw, 0);
);

function apass_set_freq(freq)
(
    freq < 10 ? freq = 10 : freq > this.ny ? freq = this.ny; 
    this.freq = freq;
    this._apass_compute_coeffs();
);

function apass_set_bw(bw)
(
    bw < 1 ? bw = 1 : bw > this.ny ? bw = this.ny;
    this.bw = bw;
    this._apass_compute_coeffs(); 
);

function apass_set_feed(feed)
(
    feed < 0 ? feed = 0 : feed > 0.999 ? feed = 0.999;
    this.feed = feed;
);

function apass_do(signal)
(
    in_ = signal + this.y * this.feed;
    tmp_ = in_ + (this.y1 * -this.b) + (this.y2 * -this.a);
    this.y = (tmp_ * this.a) + (this.y1 * this.b) + this.y2;
    this.y2 = this.y1; this.y1 = tmp_;
    this.y;
);

/******************************************************* 
HILBERT
=======

Hilbert transform.

Description
-----------

Hilbert is an IIR filter based implementation of a broad-band 90 degree
phase difference network. The outputs of hilbert have an identical
frequency response to the input (i.e. they sound the same), but the two
outputs have a constant phase difference of 90 degrees, plus or minus some
small amount of error, throughout the entire frequency range. The outputs
are in quadrature.

Hilbert is useful in the implementation of many digital signal processing
techniques that require a signal in phase quadrature. The real part corresponds
to the cosine output of hilbert, while the imaginary part corresponds to the
sine output. The two outputs have a constant phase difference throughout the
audio range that corresponds to the phase relationship between cosine and sine 
waves.

It must be used with a variable name as prefix (object oriented).

Initializer
-----------

#### hilbert() ####

Initializes a sixth-order IIR Hilbert filter.

Methods
-------

#### hilbert_do(signal) ####

Processes one samples of an input signal `signal` and stores the real part 
in the `real` attribute and the imaginary part in the `imag` attribute.

Attributes
----------

#### hilbert.real ####

Floating-point value that holds the real part of the complex filtering. 

#### hilbert.imag ####

Floating-point value that holds the imaginary part of the complex filtering. 

Example
-------

    desc:Single-Sideband-Modulation Via The Hilbert Transform

    import cookdsp.jsfx-inc

    slider1:1000<1,2000>Shifting Frequency (Hz)
    slider2:0<0,1,1{Down Shifting, Up Shifting}>Shifting Sideband

    @init
    // Initializes the Hilbert transform
    hilb.hilbert();
    // Sinusoid phase
    ph.phasor(slider1, 0);

    @slider
    ph.phasor_set_freq(slider1);

    @sample
    // Mixed input
    input = (spl0 + spl1) * 0.5;
    // Complex phase
    ph1 = ph.phasor_do();
    ph2 = wrap(ph1+0.25, 0, 1);
    // Complex sinusoid
    q1 = sin(2 * $pi * ph1);
    q2 = sin(2 * $pi * ph2);
    // Hilbert transform
    hilb.hilbert_do(input);
    // Complex modulation
    mod1 = hilb.real * q1;
    mod2 = hilb.imag * q2;
    // Sideband separation
    down = mod1 + mod2;
    up = mod1 - mod2;
    // Choose the desired sideband
    slider2 == 0 ? side = down : side = up;
    // Mix the sideband with input signal
    spl0 = (spl0 + side) * 0.5;
    spl1 = (spl1 + side) * 0.5;

********************************************************/
function hilbert()
(
    this.real = this.imag = 0.0;
    this.poles.buffer(12);
    this.poles.buffer_init(.3609, 2.7412, 11.1573, 44.7581, 179.6242,
                           798.4578, 1.2524, 5.5671, 22.3423, 89.6271, 
                           364.7914, 2770.1114);
    this.coeffs.buffer(12);
    this.x1.buffer(12);
    this.y1.buffer(12);
    twopi_ = $pi * 2;
    i_ = 0;
    loop(12,
        pf_ = this.poles.buffer_fread(i_) * 15.0;
        rc_ = 1.0 / (twopi_ * pf_);
        al_ = 1.0 / rc_;
        fac_ = al_ / (2.0 * srate);
        beta_ = (1.0 - fac_) / (1.0 + fac_);
        this.coeffs.buffer_write(i_, -beta_);
        i_ += 1;
    );
);

function hilbert_do(signal)
(
    xn1_ = signal;
    i_ = 0;
    loop(6,
        c_ = this.coeffs.buffer_fread(i_);
        x1_ = this.x1.buffer_fread(i_);
        y1_ = this.y1.buffer_fread(i_);
        yn1_ = x1_ + (xn1_ - y1_) * c_;
        this.x1.buffer_write(i_, xn1_);
        this.y1.buffer_write(i_, yn1_);
        xn1_ = yn1_;
        i_ += 1;
    );
    xn2_ = signal;
    loop(6,
        c_ = this.coeffs.buffer_fread(i_);
        x2_ = this.x1.buffer_fread(i_);
        y2_ = this.y1.buffer_fread(i_);
        yn2_ = x2_ + (xn2_ - y2_) * c_;
        this.x1.buffer_write(i_, xn2_);
        this.y1.buffer_write(i_, yn2_);
        xn2_ = yn2_;
        i_ += 1;
    );
    this.real = yn1_;
    this.imag = yn2_;
);

/******************************************************* 
BIQUAD
======

A sweepable general purpose biquadratic digital filter.

Description
-----------

The `biquad` object initializes a second-order IIR general purpose 
biquadratic digital filter. It takes the cutoff frequency `freq`, 
in Hz, the quality factor `q` (as `freq` / `bandwidth`) and the 
filter's type `type`, as argument.

It must be used with a variable name as prefix (object oriented).

Initializer
-----------

#### biquad(freq, q, type) ####

Initializes a second-order IIR general purpose biquadratic digital filter. 
It takes the cutoff frequency `freq`, in Hz, the quality factor `q` 
(as `freq` / `bandwidth`) and the filter's type `type`, as argument. 
Possible types are:

    - 0 : lowpass
    - 1 : highpass
    - 2 : bandpass
    - 3 : bandstop
    - 4 : allpass

Methods
-------

#### biquad_set_freq(freq) ####

Sets a new cutoff frequency `freq`, in Hz.

#### biquad_set_q(q) ####

Sets a new quality factor `q` (as `freq` / `bandwidth`).

#### biquad_set_type(type) ####

Sets a new filter's type. Possible types are:

    - 0 : lowpass
    - 1 : highpass
    - 2 : bandpass
    - 3 : bandstop
    - 4 : allpass

#### biquad_do(signal) ####

Processes one samples of an input signal `signal` and outputs
the filtered sample.

Example
-------

    desc:Resonant Multi-type Filter

    import cookdsp.jsfx-inc

    slider1:3500<100,10000>Cutoff Frequency In Hz
    slider2:5<1,100>Quality Factor (Q)
    slider3:0<0,4,1{lowpass,highpass,bandpass,bandstop,allpass}>Filter Type

    @init
    // Initializes the filter
    filt1.biquad(slider1, slider2, slider3);
    filt2.biquad(slider1, slider2, slider3);

    @slider
    filt1.biquad_set_freq(slider1);
    filt2.biquad_set_freq(slider1);
    filt1.biquad_set_q(slider2);
    filt2.biquad_set_q(slider2);
    filt1.biquad_set_type(slider3);
    filt2.biquad_set_type(slider3);

    @sample
    // Filters the input signal
    spl0 = filt1.biquad_do(spl0);
    spl1 = filt2.biquad_do(spl1);

********************************************************/
function _biquad_compute_lp_coeffs()
(
    this.b0 = this.b2 = (1 - this.c) / 2;
    this.b1 = 1 - this.c;
    this.a0 = 1 + this.alpha;
    this.a1 = -2 * this.c;
    this.a2 = 1 - this.alpha;
);

function _biquad_compute_hp_coeffs()
(
    this.b0 = (1 + this.c) / 2;
    this.b1 = -(1 + this.c);
    this.b2 = this.b0;
    this.a0 = 1 + this.alpha;
    this.a1 = -2 * this.c;
    this.a2 = 1 - this.alpha;
);

function _biquad_compute_bp_coeffs()
(
    this.b0 = this.alpha;
    this.b1 = 0;
    this.b2 = -this.alpha;
    this.a0 = 1 + this.alpha;
    this.a1 = -2 * this.c;
    this.a2 = 1 - this.alpha;
);

function _biquad_compute_bs_coeffs()
(
    this.b0 = 1;
    this.b1 = this.a1 = -2 * this.c;
    this.b2 = 1;
    this.a0 = 1 + this.alpha;
    this.a2 = 1 - this.alpha;
);

function _biquad_compute_ap_coeffs()
(
    this.b0 = this.a2 = 1 - this.alpha;
    this.b1 = this.a1 = -2 * this.c;
    this.b2 = this.a0 = 1 + this.alpha;
);

function _biquad_compute_vars(freq q)
(
    freq <= 0.1 ? freq = 0.1 : freq > this.ny ? freq = this.ny;
    this.freq = freq;
    q < 0.1 ? q = 0.1;
    this.q = q;
    w0 = this.twopi * this.freq / srate;
    this.c = cos(w0);
    this.alpha = sin(w0) / (2 * this.q);
    this.type == 0 ? this._biquad_compute_lp_coeffs() :
    this.type == 1 ? this._biquad_compute_hp_coeffs() :
    this.type == 2 ? this._biquad_compute_bp_coeffs() :
    this.type == 3 ? this._biquad_compute_bs_coeffs() :
    this.type == 4 ? this._biquad_compute_ap_coeffs();
);

function biquad(freq q type)
(
    this.x1 = this.x2 = this.y1 = this.y2 = 0.0;
    this.twopi = $pi * 2;
    this.ny = srate * 0.49;
    type < 0 ? type = 0 : type > 4 ? type = 4;
    this.type = type;
    this._biquad_compute_vars(freq, q);
);

function biquad_set_freq(freq)
(
    freq != this.freq ? this._biquad_compute_vars(freq, this.q);
);

function biquad_set_q(q)
(
    q != this.q ? this._biquad_compute_vars(this.freq, q);
);

function biquad_set_type(type)
(
    type != this.type ? (
        type < 0 ? type = 0 : type > 4 ? type = 4;
        this.type = type;
        this._biquad_compute_vars(this.freq, this.q);
    );
);

function biquad_do(signal)
(
    tmp_ = (this.b0 * signal + this.b1 * this.x1 + this.b2 * this.x2 - this.a1 * this.y1 - this.a2 * this.y2) / this.a0;
    this.x2 = this.x1; this.x1 = signal; this.y2 = this.y1; this.y1 = tmp_;
    tmp_;
);

/******************************************************* 
MOOG
====

24dB/oct resonant lowpass filter.

Description
-----------

Implementation of the Moog ladder filter based on the work of Antti 
Huovilainen, described in the paper "Non-Linear Digital Implementation 
of the Moog Ladder Filter" (Proceedings of DaFX04, University of Napoli).
Adapted from Csound code for the moogladder opcode (Victor Lazzarini).

It must be used with a variable name as prefix (object oriented).

Initializer
-----------

#### moog(freq, res) ####

Initializes a fourth-order IIR resonant lowpass filter with cutoff
frequency `freq`, in Hz, and amount of resonance `res`, between 0
(no resonance) and 1 (self-oscillation). 

Methods
-------

#### moog_set_freq(freq) ####

Sets a new cutoff frequency `freq`, in Hz.

#### moog_set_res(res) ####

Sets a new resonance factor, between 0 and 1.

#### moog_do(signal) ####

Processes one samples of an input signal `signal` and outputs
the filtered sample.

Example
-------

    desc:24dB/oct Resonant Lowpass Filter

    import cookdsp.jsfx-inc

    slider1:3500<100,12000>Cutoff Frequency in Hz
    slider2:0.5<0,1>Resonance

    @init
    // Initializes the filter
    filt1.moog(slider1, slider2);
    filt2.moog(slider1, slider2);

    @slider
    filt1.moog_set_freq(slider1);
    filt2.moog_set_freq(slider1);
    filt1.moog_set_res(slider2);
    filt2.moog_set_res(slider2);

    @sample
    // Filters the input signal
    spl0 = filt1.moog_do(spl0);
    spl1 = filt2.moog_do(spl1);

********************************************************/
function _moog_compute_coeffs(freq res)
(
    freq < 1 ? freq = 1 : freq > this.ny ? freq = this.ny;
    this.freq = freq; 
    res < 0 ? res = 0 : res > 1 ? res = 1;
    this.res = res;
    // srate is half the actual filter sampling rate
    fc_ = this.freq / srate;
    f_  =  0.5 * fc_;
    fc2_ = fc_ * fc_;
    fc3_ = fc2_ * fc_;
    // frequency & amplitude correction
    fcr_ = 1.8730 * fc3_ + 0.4955 * fc2_ - 0.6490 * fc_ + 0.9988;
    acr_ = -3.9364 * fc2_ + 1.8409 * fc_ + 0.9968;
    this.scl = (1.0 - exp(-2 * $pi * f_ * fcr_)) / this.z; // filter tuning
    this.r4 = 3.96 * this.res * acr_; // filter feedback
);

function moog(freq res)
(
    this.y1 = this.y2 = this.y3 = this.y4 = this.y5 = this.out = 0;
    this.ny = srate * 0.49;
    this.z = 1/40000; // twice the "thermal voltage of a transistor"
    this._moog_compute_coeffs(freq, res);
);

function moog_set_freq(freq)
(
    freq != this.freq ? this._moog_compute_coeffs(freq, this.res);
);

function moog_set_res(res)
(
    res != this.res ? this._moog_compute_coeffs(this.freq, res);
);

function moog_do(signal)
(
    loop(2,
        this.y1 = this.y1 + this.scl * (tanh((signal - this.r4 * this.out) * this.z) - tanh(this.y1*this.z));
        this.y2 = this.y2 + this.scl * (tanh(this.y1 * this.z) - tanh(this.y2 * this.z));
        this.y3 = this.y3 + this.scl * (tanh(this.y2 * this.z) - tanh(this.y3 * this.z));
        this.y4 = this.y4 + this.scl * (tanh(this.y3 * this.z) - tanh(this.y4 * this.z));
        this.out = (this.y4 + this.y5) * 0.5;
        this.y5 = this.y4;
    );
    this.out;
);


/******************************************************* 
COMB
====

Reverberates an input signal with a colored frequency response.

Description
-----------

Comb creates a comb filter with peaks in the spectrum located at all
multiples of `1 / delay time`. This kind of filter is often used in simple 
digital reverb implementations.

It must be used with a variable name as prefix (object oriented).

Initializer
-----------

#### comb(delay, feed) ####

Initializes acomb filter with frequency as the inverse of the delay
time `delay`, in seconds, and feedback `feed`, between 0 and 1. 

Methods
-------

#### comb_set_delay(delay) ####

Sets a new delay time, in seconds.

#### comb_set_feed(feed) ####

Sets a new feedback factor, between 0 and 1.

#### comb_do(signal) ####

Processes one samples of an input signal `signal` and outputs
the filtered sample.

Example
-------

    desc:Schroeder Reverb 2

    import cookdsp.jsfx-inc

    slider1:3500<500,10000>Lowpass Cutoff
    slider2:0.2<0,1>Balance Dry/Wet

    @init
    // Left ch. comb filters        Right ch. comb filters
    c1L.comb(0.0297, 0.65);         c1R.comb(0.0277, 0.65);
    c2L.comb(0.0371, 0.51);         c2R.comb(0.0393, 0.51);
    c3L.comb(0.0411, 0.5);          c3R.comb(0.0409, 0.5);
    c4L.comb(0.0137, 0.73);         c4R.comb(0.0155, 0.73);
    // Left ch. allpass filters     Right ch. allpass filters
    a1L.allpass(0.005, 0.75);       a1R.allpass(0.00507, 0.75);
    a2L.allpass(0.0117, 0.61);      a2R.allpass(0.0123, 0.61);
    // Left ch. lowpass filter      Right ch. lowpass filter
    lpL.lop(3500);                  lpR.lop(3500);

    @slider
    lpL.lop_set_freq(slider1);
    lpR.lop_set_freq(slider1);

    @sample
    // Left ch. comb filters        Right ch. comb filters
    sig1L = c1L.comb_do(spl0);      sig1R = c1R.comb_do(spl1);
    sig2L = c2L.comb_do(spl0);      sig2R = c2R.comb_do(spl1);
    sig3L = c3L.comb_do(spl0);      sig3R = c3R.comb_do(spl1);
    sig4L = c4L.comb_do(spl0);      sig4R = c4R.comb_do(spl1);
    // Comb filters summation
    sumL = spl0 + sig1L + sig2L + sig3L + sig4L;
    sumR = spl1 + sig1R + sig2R + sig3R + sig4R;
    // Left ch. allpass filters     Right ch. allpass filters
    all1L = a1L.allpass_do(sumL);   all1R = a1R.allpass_do(sumR);
    all2L = a2L.allpass_do(all1L);  all2R = a2R.allpass_do(all1R);
    // Left ch. lowpass filter      Right ch. lowpass filter
    sigL = lpL.lop_do(all2L) * .2;  sigR = lpR.lop_do(all2R) * .2;
    // Balance and output
    spl0 = spl0 + (sigL - spl0) * slider2;
    spl1 = spl1 + (sigR - spl1) * slider2;

********************************************************/
function comb(delay feed)
(
    this.dline.delay(srate/2);
    delay < 1/srate ? delay = 1/srate : delay > 0.5 ? delay = 0.5;
    this.delay = delay;
    feed < 0 ? feed = 0 : feed > 1 ? feed = 1;
    this.feed = feed;
);

function comb_set_delay(delay)
(
    delay < 1/srate ? delay = 1/srate : delay > 0.5 ? delay = 0.5;
    this.delay = delay;
);

function comb_set_feed(feed)
(
    feed < 0 ? feed = 0 : feed > 1 ? feed = 1;
    this.feed = feed;
);

function comb_do(signal)
(
    tmp_ = this.dline.delay_fsread2(this.delay);
    this.dline.delay_write(signal + tmp_ * this.feed);
    tmp_;
);

/******************************************************* 
ALLPASS
=======

Reverberates an input signal with a flat frequency response.

Description
-----------

Allpass is based on the combination of feedforward and feedback comb filter. 
This kind of filter is often used in simple digital reverb implementations.

It must be used with a variable name as prefix (object oriented).

Initializer
-----------

#### allpass(delay, feed) ####

Initializes an allpass filter with frequency as the inverse of the delay
time `delay`, in seconds, and feedback `feed`, between 0 and 1. 

Methods
-------

#### allpass_set_delay(delay) ####

Sets a new delay time, in seconds.

#### allpass_set_feed(feed) ####

Sets a new feedback factor, between 0 and 1.

#### allpass_do(signal) ####

Processes one samples of an input signal `signal` and outputs
the filtered sample.

Example
-------

    desc:Schroeder Reverb 1

    import cookdsp.jsfx-inc

    slider1:0.2<0,1>Balance Dry/Wet

    @init
    // Left ch. allpass filters     Right ch. allpass filters
    a1L.allpass(0.0204, 0.35);      a1R.allpass(0.02011, 0.35);
    a2L.allpass(0.06653, 0.41);     a2R.allpass(0.06641, 0.41);
    a3L.allpass(0.035007, 0.5);     a3R.allpass(0.03504, 0.5);
    a4L.allpass(0.023021, 0.65);    a4R.allpass(0.022987, 0.65);
    // Left ch. lowpass filters     Right ch. lowpass filters
    lp1L.lop(5000);                 lp1R.lop(5000);
    lp2L.lop(3000);                 lp2R.lop(3000);
    lp3L.lop(1500);                 lp3R.lop(1500);
    lp4L.lop(500);                  lp4R.lop(500);
        
    @sample
    // Left channel                 Right channel                 
    sig1L = a1L.allpass_do(spl0);   sig1R = a1R.allpass_do(spl1);
    sig2L = a2L.allpass_do(sig1L);  sig2R = a2R.allpass_do(sig1R);
    sig3L = a3L.allpass_do(sig2L);  sig3R = a3R.allpass_do(sig2R);
    sig4L = a4L.allpass_do(sig3L);  sig4R = a4R.allpass_do(sig3R);
    lop1L = lp1L.lop_do(sig1L);     lop1R = lp1R.lop_do(sig1R);
    lop2L = lp2L.lop_do(sig2L);     lop2R = lp2R.lop_do(sig2R);
    lop3L = lp3L.lop_do(sig3L);     lop3R = lp3R.lop_do(sig3R);
    lop4L = lp4L.lop_do(sig4L);     lop4R = lp4R.lop_do(sig4R);
    sigL = (lop1L + lop2L + lop3L + lop4L) * 0.5;
    sigR = (lop1R + lop2R + lop3R + lop4R) * 0.5;
    spl0 = spl0 + (sigL - spl0) * slider1;
    spl1 =  spl1 + (sigR - spl1) * slider1;

********************************************************/
function allpass(delay feed)
(
    this.dline.delay(srate/2);
    delay < 1/srate ? delay = 1/srate : delay > 0.5 ? delay = 0.5;
    this.delay = delay;
    feed < 0 ? feed = 0 : feed > 1 ? feed = 1;
    this.feed = feed;
);

function allpass_set_delay(delay)
(
    delay < 1/srate ? delay = 1/srate : delay > 0.5 ? delay = 0.5;
    this.delay = delay;
);

function allpass_set_feed(feed)
(
    feed < 0 ? feed = 0 : feed > 1 ? feed = 1;
    this.feed = feed;
);

function allpass_do(signal)
(
    tmp_ = this.dline.delay_fsread2(this.delay);
    this.dline.delay_write(signal + tmp_ * this.feed);
    tmp_ * (1 - this.feed * this.feed) + signal * -this.feed;
);

/******************************************************* 
EQ
===

Equalizer filter.

Description
-----------

EQ is a biquadratic digital filter designed for equalization. 
It provides peak/notch and lowshelf/highshelf filters for building 
parametric equalizers.

It must be used with a variable name as prefix (object oriented).

Initializer
-----------

#### eq(freq, q, boost, type) ####

Initializes a second-order IIR equalizer filter. It takes as arguments the 
center (or cutoff) frequency `freq`, in Hz, the quality factor `q` 
(defined as `freq` / `bandwidth`), the amount of boost/cut, expressed in 
dB, and the filter's type `type`. Possible types are:

    - 0 : peak/notch
    - 1 : lowshelf
    - 2 : highshelf

Methods
-------

#### eq_set_freq(freq) ####

Sets a new center or cutoff frequency `freq`, in Hz.

#### eq_set_q(q) ####

Sets a new quality factor `q` (defined as `freq` / `bandwidth`).

#### eq_set_boost(boost) ####

Sets a new boost/cut gain factor, expressed in dB (0 dB is nominal gain).

#### eq_set_type(type) ####

Sets a new filter's type. Possible types are:

    - 0 : peak/notch
    - 1 : lowshelf
    - 2 : highshelf

#### eq_do(signal) ####

Processes one samples of an input signal `signal` and outputs
the filtered sample.

Example
-------

    desc:Parametric EQ Filter

    import cookdsp.jsfx-inc

    slider1:1000<100,10000>Center Frequency
    slider2:1<0.5,20>Filter Q
    slider3:0<-18,18>Boost/Cut (dB)
    slider4:0<0,2,1{Peak/Notch,Lowshelf,Highshelf}>Filter type

    @init
    f1.eq(slider1, slider2, slider3, slider4);
    f2.eq(slider1, slider2, slider3, slider4);

    @slider
    f1.eq_set_freq(slider1); f2.eq_set_freq(slider1);
    f1.eq_set_q(slider2); f2.eq_set_q(slider2);
    f1.eq_set_boost(slider3); f2.eq_set_boost(slider3);
    f1.eq_set_type(slider4); f2.eq_set_type(slider4);

    @sample
    spl0 = f1.eq_do(spl0);
    spl1 = f2.eq_do(spl1);

********************************************************/
function _eq_compute_peak_coeffs()
(
    amul_ = this.alpha * this.a;
    adiv_ = this.alpha / this.a;
    this.b0 = 1.0 + amul_;
    this.b1 = this.a1 = -2.0 * this.c;
    this.b2 = 1.0 - amul_;
    this.a0 = 1 + adiv_;
    this.a2 = 1 - adiv_;
);

function _eq_compute_ls_coeffs()
(
    sqrt2a_ = sqrt(this.a * 2.0) * this.alpha;
    amin1c_ = (this.a - 1.0) * this.c;
    aadd1c_ = (this.a + 1.0) * this.c;
    this.b0 = this.a * ((this.a + 1.0) - amin1c_ + sqrt2a_);
    this.b1 = 2.0 * this.a * ((this.a - 1.0) - aadd1c_);
    this.b2 = this.a * ((this.a + 1.0) - amin1c_ - sqrt2a_);
    this.a0 = (this.a + 1.0) + amin1c_ + sqrt2a_;
    this.a1 = -2.0 * ((this.a - 1.0) + aadd1c_);
    this.a2 = (this.a + 1.0) + amin1c_ - sqrt2a_;
);

function _eq_compute_hs_coeffs()
(
    sqrt2a_ = sqrt(this.a * 2.0) * this.alpha;
    amin1c_ = (this.a - 1.0) * this.c;
    aadd1c_ = (this.a + 1.0) * this.c;
    this.b0 = this.a * ((this.a + 1.0) + amin1c_ + sqrt2a_);
    this.b1 = -2.0 * this.a * ((this.a - 1.0) + aadd1c_);
    this.b2 = this.a * ((this.a + 1.0) + amin1c_ - sqrt2a_);
    this.a0 = (this.a + 1.0) - amin1c_ + sqrt2a_;
    this.a1 = 2.0 * ((this.a - 1.0) - aadd1c_);
    this.a2 = (this.a + 1.0) - amin1c_ - sqrt2a_;
);

function _eq_compute_vars(freq q boost)
(
    freq <= 1 ? freq = 1 : freq > this.ny ? freq = this.ny;
    this.freq = freq;
    q < 0.1 ? q = 0.1;
    this.q = q;
    this.boost = boost;

    this.a = pow(10, boost/40);
    w0 = this.twopi * this.freq / srate;
    this.c = cos(w0);
    this.alpha = sin(w0) / (2 * this.q);
    this.type == 0 ? this._eq_compute_peak_coeffs() :
    this.type == 1 ? this._eq_compute_ls_coeffs() :
    this.type == 2 ? this._eq_compute_hs_coeffs();
);

function eq(freq q boost type)
(
    this.x1 = this.x2 = this.y1 = this.y2 = 0.0;
    this.twopi = $pi * 2;
    this.ny = srate * 0.49;
    type < 0 ? type = 0 : type > 2 ? type = 2;
    this.type = type;
    this._eq_compute_vars(freq, q, boost);
);

function eq_set_freq(freq)
(
    freq != this.freq ? this._eq_compute_vars(freq, this.q, this.boost);
);

function eq_set_q(q)
(
    q != this.q ? this._eq_compute_vars(this.freq, q, this.boost);
);

function eq_set_boost(boost)
(
    boost != this.boost ? this._eq_compute_vars(this.freq, this.q, boost);
);

function eq_set_type(type)
(
    type != this.type ? (
        type < 0 ? type = 0 : type > 2 ? type = 2;
        this.type = type;
        this._eq_compute_vars(this.freq, this.q, this.boost);
    );
);

function eq_do(signal)
(
    tmp_ = (this.b0 * signal + this.b1 * this.x1 + this.b2 * this.x2 - this.a1 * this.y1 - this.a2 * this.y2) / this.a0;
    this.x2 = this.x1; this.x1 = signal; this.y2 = this.y1; this.y1 = tmp_;
    tmp_;
);















last_gain=10^(gain_db/20);

//
// Var Initializations
//
L_Osc_Phase = 0;
R_Osc_Phase = 0;
L_Osc_Dt = 0;
R_Osc_Dt = 0;

MAX_BUFLEN_MS = 1000;
MAX_BUFLEN_SPL = MAX_BUFLEN_MS / 1000 * srate;

L_BufPos = 0;
R_BufPos = 0; 

PI = 3.141592653589793238462643383279502884;
D_PI = PI*2;

L_Delay_Buf = 0;
R_Delay_Buf = L_Delay_Buf + MAX_BUFLEN_SPL;

memset(L_Delay_Buf, 0, MAX_BUFLEN_SPL);
memset(R_Delay_Buf, 0, MAX_BUFLEN_SPL);
filt1.biquad(slider22, slider23, 0);
filt2.biquad(slider22, slider23, 0);

// Ripple Prevention
FilteredOscBufLen = 50;
L_FilteredOscBuf = R_Delay_Buf + MAX_BUFLEN_SPL;
R_FilteredOscBuf = L_FilteredOscBuf + FilteredOscBufLen;
L_FilteredOscBuf_Pos = 0;
R_FilteredOscBuf_Pos = 0;
memset(L_FilteredOscBuf, 0, FilteredOscBufLen);
memset(R_FilteredOscBuf, 0, FilteredOscBufLen);
lmin = rmin = 0;

// GUi
pad_mousedown = 0;

@slider
next_gain=10^(gain_db/20);

filt1.biquad_set_freq(slider22);
filt2.biquad_set_freq(slider22);
filt1.biquad_set_q(slider23);
filt2.biquad_set_q(slider23);
slider21 > 0 ? (
  filt1.biquad_set_type(slider21-1);
  filt2.biquad_set_type(slider21-1);
);

slider24 == 1 ? (
  memset(L_Delay_Buf, 0, MAX_BUFLEN_SPL);
  memset(R_Delay_Buf, 0, MAX_BUFLEN_SPL);
); 


@block
d_gain = (next_gain - last_gain)/samplesblock;

@sample
// push samples to ring buffer
L_Delay_Buf[L_BufPos] = spl0;
R_Delay_Buf[R_BufPos] = spl1;

// proc oscillator
L_DelayTime = slider2 + slider3 + (slider4 < 0 ? abs(slider4) : 0);
L_DelayTime = L_DelayTime / 1000 * srate;
R_DelayTime = slider2 + slider3 + (slider4 > 0 ? abs(slider4) : 0);
R_DelayTime = R_DelayTime / 1000 * srate;

L_Osc_Dt = osc_freq / srate * D_PI;
R_Osc_Dt = (osc_freq + osc_freq_spread) / srate * D_PI;

slider15 == 0 ? ( // Sine
  slider21 == 0 ? (
    L_DelayTime = L_DelayTime * (sin(L_Osc_Phase)/2+0.5); 
    R_DelayTime = R_DelayTime * (sin(R_Osc_Phase)/2+0.5);
  ) : (
    osc_l = filt1.biquad_do(sin(L_Osc_Phase))/2+0.5; 
    osc_r = filt2.biquad_do(sin(R_Osc_Phase))/2+0.5;
  );
); 
slider15 == 1 ? ( // Tri
  slider21 == 0 ? (
    L_DelayTime = L_DelayTime * ( 0.5 - asin(sin(L_Osc_Phase))/PI ); 
    R_DelayTime = R_DelayTime * ( 0.5 - asin(sin(R_Osc_Phase))/PI );
  ) : (
    osc_l = filt1.biquad_do(-asin(sin(L_Osc_Phase))/PI) + 0.5;
    osc_r = filt2.biquad_do(-asin(sin(R_Osc_Phase))/PI) + 0.5;
  );
);
slider15 == 2 ? ( // Square
  slider21 == 0 ? (
    L_DelayTime = L_DelayTime * ( sin(L_Osc_Phase) >= 0 ? 1 : 0 ); 
    R_DelayTime = R_DelayTime * ( sin(R_Osc_Phase) >= 0 ? 1 : 0 );
  ) : (
    osc_l = filt1.biquad_do(sin(L_Osc_Phase) >= 0 ? 0.5 : -0.5);
    osc_r = filt2.biquad_do(sin(R_Osc_Phase) >= 0 ? 0.5 : -0.5);
  );
);
slider15 == 3 ? ( // Saw up
  slider21 == 0 ? (
    L_DelayTime = L_DelayTime * ( L_Osc_Phase/D_PI - floor(L_Osc_Phase/D_PI) ); 
    R_DelayTime = R_DelayTime * ( R_Osc_Phase/D_PI - floor(R_Osc_Phase/D_PI) ); 
  ) : (
    osc_l = filt1.biquad_do(L_Osc_Phase/D_PI - floor(L_Osc_Phase/D_PI) - 0.5);
    osc_r = filt2.biquad_do(R_Osc_Phase/D_PI - floor(R_Osc_Phase/D_PI) - 0.5);
  );
);
slider15 == 4 ? ( // Saw down
  slider21 == 0 ? (
    L_DelayTime = L_DelayTime * ( -L_Osc_Phase/D_PI + floor(L_Osc_Phase/D_PI) + 1 ); 
    R_DelayTime = R_DelayTime * ( -R_Osc_Phase/D_PI + floor(R_Osc_Phase/D_PI) + 1 );  
  ) : (
    osc_l = filt1.biquad_do(-L_Osc_Phase/D_PI + floor(L_Osc_Phase/D_PI) + 0.5);
    osc_r = filt2.biquad_do(-R_Osc_Phase/D_PI + floor(R_Osc_Phase/D_PI) + 0.5);
  ); 
);
slider15 == 5 ? ( // Mono noise
  slider21 == 0 ? (
    L_DelayTime = L_DelayTime * rand(1.0); 
    R_DelayTime = L_DelayTime;
  ) : (
    osc_l = filt1.biquad_do(rand(1.0)-0.5);
    osc_r = osc_l;
  ); 
);
slider15 == 6 ? ( // Stereo Noise
  slider21 == 0 ? (
    L_DelayTime = L_DelayTime * rand(1.0); 
    R_DelayTime = R_DelayTime * rand(1.0);
  ) : (
    osc_l = filt1.biquad_do(rand(1.0)-0.5);
    osc_r = filt2.biquad_do(rand(1.0)-0.5);
  ); 
 
);
slider15 == 7 ? ( // Self
  slider21 == 0 ? (
    osc_l = L_Delay_Buf[L_BufPos];
    osc_r = R_Delay_Buf[R_BufPos];
  ) : (
    osc_l = filt1.biquad_do(L_Delay_Buf[L_BufPos]);
    osc_r = filt2.biquad_do(R_Delay_Buf[R_BufPos]);
  ); 
  
);

function clamp(var, left, right, range) local(ret)
(
  ret = var;
  while(ret < left)
  (
    ret += range;
  );
  while(right < ret)
  (
    ret -= range;
  );
  ret;
);

// Compensate Gibbs (Add DC Offset and offset osc above 0)
slider21 != 0 || slider15 == 7 ? (
    L_FilteredOscBuf[L_FilteredOscBuf_Pos] = osc_l;
    R_FilteredOscBuf[R_FilteredOscBuf_Pos] = osc_r;
    lmin = 0;
    rmin = 0;
    bufpos = 0;
    loop(FilteredOscBufLen,
      lmin > L_FilteredOscBuf[bufpos] ? lmin = L_FilteredOscBuf[bufpos];
      rmin > R_FilteredOscBuf[bufpos] ? rmin = R_FilteredOscBuf[bufpos];
      bufpos+=1;
    );
    slider24 == 0 ? (
      osc_l -= lmin;
      osc_r -= rmin;
    );
  L_DelayTime = L_DelayTime * osc_l; 
  R_DelayTime = R_DelayTime * osc_r;
);

// Update Oscillator Phase
  L_Osc_Phase += L_Osc_Dt;
  R_Osc_Phase += R_Osc_Dt;
  L_Osc_Phase > D_PI ? L_Osc_Phase -= D_PI;
  R_Osc_Phase > D_PI ? R_Osc_Phase -= D_PI;

// apply delay
slider30 == 0 ?
(
  // None (Nearest Neighbor)
  L_Buf_Readpos = clamp(-L_DelayTime + L_BufPos, 0, MAX_BUFLEN_SPL-1, MAX_BUFLEN_SPL);
  R_Buf_Readpos = clamp(-R_DelayTime + R_BufPos, 0, MAX_BUFLEN_SPL-1, MAX_BUFLEN_SPL);

  spl0 = L_Delay_Buf[L_Buf_Readpos];
  spl1 = R_Delay_Buf[R_Buf_Readpos];
);
slider30 == 1 ?
(
  // Linear
  L_delay_t1 = floor(L_DelayTime);
  L_delay_t2 = floor(L_DelayTime)+1;
  R_delay_t1 = floor(R_DelayTime);
  R_delay_t2 = floor(R_DelayTime)+1;
  
  L_delay_A1 = L_Delay_Buf[ clamp(-L_delay_t1 + L_BufPos, 0, MAX_BUFLEN_SPL-1, MAX_BUFLEN_SPL) ];
  L_delay_A2 = L_Delay_Buf[ clamp(-L_delay_t2 + L_BufPos, 0, MAX_BUFLEN_SPL-1, MAX_BUFLEN_SPL) ];
  R_delay_A1 = R_Delay_Buf[ clamp(-R_delay_t1 + R_BufPos, 0, MAX_BUFLEN_SPL-1, MAX_BUFLEN_SPL) ];
  R_delay_A2 = R_Delay_Buf[ clamp(-R_delay_t2 + R_BufPos, 0, MAX_BUFLEN_SPL-1, MAX_BUFLEN_SPL) ];
  
  spl0 = (L_delay_A2 - L_delay_A1) / ( (L_delay_t2-L_delay_t1)/(L_DelayTime-L_delay_t1) ) + L_delay_A1;
  spl1 = (R_delay_A2 - R_delay_A1) / ( (R_delay_t2-R_delay_t1)/(R_DelayTime-R_delay_t1) ) + R_delay_A1;
);
slider30 == 2 ?
(
  // Cubic 
  L_delay_t1 = floor(L_DelayTime);
  L_delay_t2 = floor(L_DelayTime)+1;
  L_delay_t3 = floor(L_DelayTime)+2;
  L_delay_t4 = floor(L_DelayTime)+3;
  R_delay_t1 = floor(R_DelayTime);
  R_delay_t2 = floor(R_DelayTime)+1;
  R_delay_t3 = floor(R_DelayTime)+2;
  R_delay_t4 = floor(R_DelayTime)+3;
  
  L_p0 = L_Delay_Buf[ clamp(-L_delay_t1 + L_BufPos, 0, MAX_BUFLEN_SPL-1, MAX_BUFLEN_SPL) ];
  L_p1 = L_Delay_Buf[ clamp(-L_delay_t2 + L_BufPos, 0, MAX_BUFLEN_SPL-1, MAX_BUFLEN_SPL) ];
  L_p2 = L_Delay_Buf[ clamp(-L_delay_t3 + L_BufPos, 0, MAX_BUFLEN_SPL-1, MAX_BUFLEN_SPL) ];
  L_p3 = L_Delay_Buf[ clamp(-L_delay_t4 + L_BufPos, 0, MAX_BUFLEN_SPL-1, MAX_BUFLEN_SPL) ];
  R_p0 = R_Delay_Buf[ clamp(-R_delay_t1 + R_BufPos, 0, MAX_BUFLEN_SPL-1, MAX_BUFLEN_SPL) ];
  R_p1 = R_Delay_Buf[ clamp(-R_delay_t2 + R_BufPos, 0, MAX_BUFLEN_SPL-1, MAX_BUFLEN_SPL) ];
  R_p2 = R_Delay_Buf[ clamp(-R_delay_t3 + R_BufPos, 0, MAX_BUFLEN_SPL-1, MAX_BUFLEN_SPL) ];
  R_p3 = R_Delay_Buf[ clamp(-R_delay_t4 + R_BufPos, 0, MAX_BUFLEN_SPL-1, MAX_BUFLEN_SPL) ];
  
  L_x = L_DelayTime - floor(L_DelayTime);
  R_x = R_DelayTime - floor(R_DelayTime);
  
  spl0 = (-1/2*L_p0+3/2*L_p1-3/2*L_p2+1/2*L_p3)*L_x^3 + (L_p0-5/2*L_p1+2*L_p2-1/2*L_p3)*L_x^2 + (-1/2*L_P0+1/2*L_p2) * L_x + L_p1;
  spl1 = (-1/2*R_p0+3/2*R_p1-3/2*R_p2+1/2*R_p3)*R_x^3 + (R_p0-5/2*R_p1+2*R_p2-1/2*R_p3)*R_x^2 + (-1/2*R_P0+1/2*R_p2) * R_x + R_p1;
);

L_BufPos += 1;
R_BufPos += 1;
L_BufPos >= MAX_BUFLEN_SPL ? L_BufPos = 0;
R_BufPos >= MAX_BUFLEN_SPL ? R_BufPos = 0;
L_FilteredOscBuf_Pos += 1;
R_FilteredOscBuf_Pos += 1;
L_FilteredOscBuf_Pos >= FilteredOscBufLen ? L_FilteredOscBuf_Pos = 0;
R_FilteredOscBuf_Pos >= FilteredOscBufLen ? R_FilteredOscBuf_Pos = 0;

spl0 *= last_gain;
spl1 *= last_gain;

// TEST SIGNAL FOR DEBUGGING
Slider24 == 1 ? play_state == 1 ? (
  spl0 = L_DelayTime / (slider2+Slider3) / 1000;
  spl1 = R_DelayTime / (slider2+Slider3) / 1000;
);

last_gain += d_gain;

@gfx 200 200

GFX_PAD_X = 30;
GFX_PAD_Y = 20;
GFX_PAD_W = 180;
GFX_PAD_H = 150;

//x_center = GFX_PAD_X +(osc_freq-100)/(18000-100)*180;
x_center = GFX_PAD_X +(log10(osc_freq)-log10(100))/(log10(18000)-log10(100))*180;
y_center = GFX_PAD_Y+GFX_PAD_H - slider2/0.3*150;

x_center < GFX_PAD_X ? x_center = GFX_PAD_X : x_center > GFX_PAD_X+GFX_PAD_W ? x_center = GFX_PAD_X+GFX_PAD_W;
y_center < GFX_PAD_Y ? y_center = GFX_PAD_Y : y_center > GFX_PAD_Y+GFX_PAD_H ? y_center = GFX_PAD_Y+GFX_PAD_H;

// mouse event
pad_mousedown == 1 ? (
  mouse_x_clamped = mouse_x;
    mouse_x_clamped < GFX_PAD_X ? mouse_x_clamped = GFX_PAD_X;
    mouse_x_clamped > GFX_PAD_X+GFX_PAD_W ? mouse_x_clamped = GFX_PAD_X+GFX_PAD_W;
  mouse_y_clamped = mouse_y;
    mouse_y_clamped < GFX_PAD_Y ? mouse_y_clamped = GFX_PAD_Y;
    mouse_y_clamped > GFX_PAD_Y+GFX_PAD_H ? mouse_y_clamped = GFX_PAD_Y+GFX_PAD_H;
  
  gfx_x=gfx_y=1;
  
  _norm_x = (mouse_x_clamped-GFX_PAD_X)/GFX_PAD_W;
  _denorm_f = _norm_x * (log10(18000)-log10(100)) + log10(100);
  _denorm_f = 10^_denorm_f;
  
  osc_freq = _denorm_f;
  
  slider2 = (GFX_PAD_H+GFX_PAD_Y - mouse_y_clamped)/GFX_PAD_H * (0.3-0) + 0;
);

pad_mousedown == 0 && mouse_cap == 1 && (GFX_PAD_X<mouse_x&&mouse_x<GFX_PAD_X+GFX_PAD_W) && (GFX_PAD_Y<mouse_y&&mouse_y<<GFX_PAD_Y+GFX_PAD_H) ? (
  pad_mousedown = 1;
);
pad_mousedown == 0 && mouse_cap == 1 && !((GFX_PAD_X<mouse_x&&mouse_x<GFX_PAD_X+GFX_PAD_W) && (GFX_PAD_Y<mouse_y&&mouse_y<<GFX_PAD_Y+GFX_PAD_H)) ? (
  pad_mousedown = -1;
);
mouse_cap != 1 ? (
  pad_mousedown = 0;
);

// Grid Line
gfx_r = gfx_g = gfx_b = 0.3;
grid_x_freq = 100;
while(grid_x_freq < 18000)
( 
  grid_x_pos = GFX_PAD_X + GFX_PAD_W * log10(grid_x_freq/100) / log10(18000/100);
  gfx_line(grid_x_pos, GFX_PAD_Y, grid_x_pos, GFX_PAD_Y+GFX_PAD_H);
  
  grid_x_freq += 10^floor(log10(grid_x_freq));
);

grid_y_pos = (1-0.2/0.3) * (GFX_PAD_H) + GFX_PAD_Y;
gfx_line(GFX_PAD_X, grid_y_pos, GFX_PAD_X+GFX_PAD_W, grid_y_pos);

// filter
function calc_freqResponse(freq, cutoffFreq, Q, mode)
(
  w = freq / cutoffFreq;
  denom = (1-w^2)^2+w^2/Q^2;
  
  mode == 1 ? ret = sqrt(((1-w^2)/denom)^2 + ((w/Q)/denom)^2); //LP
  mode == 2 ? ret = sqrt(((1-w^2)*(-w^2)/denom)^2 + ((w/Q)*(-w^2)/denom)^2); //HP
  mode == 3 ? ret = sqrt(((1-w^2)*w/denom)^2 + ((w*w/Q)/denom)^2); //BP
  
  ret;
);

freq_fil = 100;
freq_increment = 10;
cutoff_fil = slider22;
Q_fil = slider23;

slider21 != 0 ? (
  prev_ampl_fil = log10(calc_freqResponse(100, cutoff_fil, Q_fil, slider21))*20;
);

slider21 != 0 ? (
  while(freq_fil < 18000)
  (
    ampl_fil = log10(calc_freqResponse(freq_fil, cutoff_fil, Q_fil, slider21))*20;
    
    prevx = GFX_PAD_X + GFX_PAD_W * log10((freq_fil-freq_increment)/100) / log10(18000/100);
    prevx = prevx < GFX_PAD_X ? GFX_PAD_X : prevx > GFX_PAD_X+GFX_PAD_W ? GFX_PAD_X+GFX_PAD_W : prevx;
    prevy = prev_ampl_fil/120*GFX_PAD_H;
    prevy *= -1;
    prevy += GFX_PAD_H/2 + GFX_PAD_Y;
    prevy = prevy < GFX_PAD_Y ? GFX_PAD_Y : prevy > GFX_PAD_Y+GFX_PAD_H ? GFX_PAD_Y+GFX_PAD_H : prevy;
    
    amplx = GFX_PAD_X + GFX_PAD_W * log10(freq_fil/100) / log10(18000/100);
    amplx = amplx < GFX_PAD_X ? GFX_PAD_X : amplx > GFX_PAD_X+GFX_PAD_W ? GFX_PAD_X+GFX_PAD_W : amplx;
    amply = ampl_fil/120*GFX_PAD_H;
    amply *= -1;
    amply += GFX_PAD_H/2 + GFX_PAD_Y;
    amply = amply < GFX_PAD_Y ? GFX_PAD_Y : amply > GFX_PAD_Y+GFX_PAD_H ? GFX_PAD_Y+GFX_PAD_H : amply;
    
    gfx_r = 0.8; gfx_g = 0.7; gfx_b = 0.1;
    gfx_line(prevx,prevy,amplx,amply,1);
    
    freq_fil += freq_increment;
    prev_ampl_fil = ampl_fil;
  );
) : (
  gfx_r = 0.8; gfx_g = 0.7; gfx_b = 0.1;
  gfx_line(GFX_PAD_X,GFX_PAD_Y+GFX_PAD_H/2,GFX_PAD_X+GFX_PAD_W,GFX_PAD_Y+GFX_PAD_H/2,1);
);

gfx_r = 1.0; gfx_g = 0.6; gfx_b = 1.0;
gfx_circle(x_center , y_center, 5, 0, 1);

gfx_r *= slider3/10;
gfx_circle(x_center , y_center, 5, 1, 1);

gfx_r = gfx_g = gfx_b = 0.6;
gfx_rect(GFX_PAD_X,GFX_PAD_Y,GFX_PAD_W,GFX_PAD_H,0);

gfx_x = 60; gfx_y = 180;
gfx_drawstr("Oscillator Freq");

gfx_x = 12; gfx_y = 80; gfx_drawstr("A");
gfx_x = 12; gfx_y = 90; gfx_drawstr("m");
gfx_x = 12; gfx_y = 100; gfx_drawstr("o");
gfx_x = 12; gfx_y = 110; gfx_drawstr("u");
gfx_x = 12; gfx_y = 120; gfx_drawstr("n");
gfx_x = 12; gfx_y = 130; gfx_drawstr("t");
